{"ast":null,"code":"/**\n * tracking - A modern approach for Computer Vision on the web.\n * @author Eduardo Lundgren <edu@rdo.io>\n * @version v1.1.2\n * @link http://trackingjs.com\n * @license BSD\n */\n(function (window, undefined) {\n  window.tracking = window.tracking || {};\n  /**\n   * Inherit the prototype methods from one constructor into another.\n   *\n   * Usage:\n   * <pre>\n   * function ParentClass(a, b) { }\n   * ParentClass.prototype.foo = function(a) { }\n   *\n   * function ChildClass(a, b, c) {\n   *   tracking.base(this, a, b);\n   * }\n   * tracking.inherits(ChildClass, ParentClass);\n   *\n   * var child = new ChildClass('a', 'b', 'c');\n   * child.foo();\n   * </pre>\n   *\n   * @param {Function} childCtor Child class.\n   * @param {Function} parentCtor Parent class.\n   */\n\n  tracking.inherits = function (childCtor, parentCtor) {\n    function TempCtor() {}\n\n    TempCtor.prototype = parentCtor.prototype;\n    childCtor.superClass_ = parentCtor.prototype;\n    childCtor.prototype = new TempCtor();\n    childCtor.prototype.constructor = childCtor;\n    /**\n     * Calls superclass constructor/method.\n     *\n     * This function is only available if you use tracking.inherits to express\n     * inheritance relationships between classes.\n     *\n     * @param {!object} me Should always be \"this\".\n     * @param {string} methodName The method name to call. Calling superclass\n     *     constructor can be done with the special string 'constructor'.\n     * @param {...*} var_args The arguments to pass to superclass\n     *     method/constructor.\n     * @return {*} The return value of the superclass method/constructor.\n     */\n\n    childCtor.base = function (me, methodName) {\n      var args = Array.prototype.slice.call(arguments, 2);\n      return parentCtor.prototype[methodName].apply(me, args);\n    };\n  };\n  /**\n   * Captures the user camera when tracking a video element and set its source\n   * to the camera stream.\n   * @param {HTMLVideoElement} element Canvas element to track.\n   * @param {object} opt_options Optional configuration to the tracker.\n   */\n\n\n  tracking.initUserMedia_ = function (element, opt_options) {\n    window.navigator.getUserMedia({\n      video: true,\n      audio: !!(opt_options && opt_options.audio)\n    }, function (stream) {\n      try {\n        element.src = window.URL.createObjectURL(stream);\n      } catch (err) {\n        element.src = stream;\n      }\n    }, function () {\n      throw Error('Cannot capture user camera.');\n    });\n  };\n  /**\n   * Tests whether the object is a dom node.\n   * @param {object} o Object to be tested.\n   * @return {boolean} True if the object is a dom node.\n   */\n\n\n  tracking.isNode = function (o) {\n    return o.nodeType || this.isWindow(o);\n  };\n  /**\n   * Tests whether the object is the `window` object.\n   * @param {object} o Object to be tested.\n   * @return {boolean} True if the object is the `window` object.\n   */\n\n\n  tracking.isWindow = function (o) {\n    return !!(o && o.alert && o.document);\n  };\n  /**\n   * Selects a dom node from a CSS3 selector using `document.querySelector`.\n   * @param {string} selector\n   * @param {object} opt_element The root element for the query. When not\n   *     specified `document` is used as root element.\n   * @return {HTMLElement} The first dom element that matches to the selector.\n   *     If not found, returns `null`.\n   */\n\n\n  tracking.one = function (selector, opt_element) {\n    if (this.isNode(selector)) {\n      return selector;\n    }\n\n    return (opt_element || document).querySelector(selector);\n  };\n  /**\n   * Tracks a canvas, image or video element based on the specified `tracker`\n   * instance. This method extract the pixel information of the input element\n   * to pass to the `tracker` instance. When tracking a video, the\n   * `tracker.track(pixels, width, height)` will be in a\n   * `requestAnimationFrame` loop in order to track all video frames.\n   *\n   * Example:\n   * var tracker = new tracking.ColorTracker();\n   *\n   * tracking.track('#video', tracker);\n   * or\n   * tracking.track('#video', tracker, { camera: true });\n   *\n   * tracker.on('track', function(event) {\n   *   // console.log(event.data[0].x, event.data[0].y)\n   * });\n   *\n   * @param {HTMLElement} element The element to track, canvas, image or\n   *     video.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   */\n\n\n  tracking.track = function (element, tracker, opt_options) {\n    element = tracking.one(element);\n\n    if (!element) {\n      throw new Error('Element not found, try a different element or selector.');\n    }\n\n    if (!tracker) {\n      throw new Error('Tracker not specified, try `tracking.track(element, new tracking.FaceTracker())`.');\n    }\n\n    switch (element.nodeName.toLowerCase()) {\n      case 'canvas':\n        return this.trackCanvas_(element, tracker, opt_options);\n\n      case 'img':\n        return this.trackImg_(element, tracker, opt_options);\n\n      case 'video':\n        if (opt_options) {\n          if (opt_options.camera) {\n            this.initUserMedia_(element, opt_options);\n          }\n        }\n\n        return this.trackVideo_(element, tracker, opt_options);\n\n      default:\n        throw new Error('Element not supported, try in a canvas, img, or video.');\n    }\n  };\n  /**\n   * Tracks a canvas element based on the specified `tracker` instance and\n   * returns a `TrackerTask` for this track.\n   * @param {HTMLCanvasElement} element Canvas element to track.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   * @return {tracking.TrackerTask}\n   * @private\n   */\n\n\n  tracking.trackCanvas_ = function (element, tracker) {\n    var self = this;\n    var task = new tracking.TrackerTask(tracker);\n    task.on('run', function () {\n      self.trackCanvasInternal_(element, tracker);\n    });\n    return task.run();\n  };\n  /**\n   * Tracks a canvas element based on the specified `tracker` instance. This\n   * method extract the pixel information of the input element to pass to the\n   * `tracker` instance.\n   * @param {HTMLCanvasElement} element Canvas element to track.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   * @private\n   */\n\n\n  tracking.trackCanvasInternal_ = function (element, tracker) {\n    var width = element.width;\n    var height = element.height;\n    var context = element.getContext('2d');\n    var imageData = context.getImageData(0, 0, width, height);\n    tracker.track(imageData.data, width, height);\n  };\n  /**\n   * Tracks a image element based on the specified `tracker` instance. This\n   * method extract the pixel information of the input element to pass to the\n   * `tracker` instance.\n   * @param {HTMLImageElement} element Canvas element to track.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   * @private\n   */\n\n\n  tracking.trackImg_ = function (element, tracker) {\n    var width = element.width;\n    var height = element.height;\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var task = new tracking.TrackerTask(tracker);\n    task.on('run', function () {\n      tracking.Canvas.loadImage(canvas, element.src, 0, 0, width, height, function () {\n        tracking.trackCanvasInternal_(canvas, tracker);\n      });\n    });\n    return task.run();\n  };\n  /**\n   * Tracks a video element based on the specified `tracker` instance. This\n   * method extract the pixel information of the input element to pass to the\n   * `tracker` instance. The `tracker.track(pixels, width, height)` will be in\n   * a `requestAnimationFrame` loop in order to track all video frames.\n   * @param {HTMLVideoElement} element Canvas element to track.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   * @private\n   */\n\n\n  tracking.trackVideo_ = function (element, tracker) {\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    var width;\n    var height;\n\n    var resizeCanvas_ = function () {\n      width = element.offsetWidth;\n      height = element.offsetHeight;\n      canvas.width = width;\n      canvas.height = height;\n    };\n\n    resizeCanvas_();\n    element.addEventListener('resize', resizeCanvas_);\n    var requestId;\n\n    var requestAnimationFrame_ = function () {\n      requestId = window.requestAnimationFrame(function () {\n        if (element.readyState === element.HAVE_ENOUGH_DATA) {\n          try {\n            // Firefox v~30.0 gets confused with the video readyState firing an\n            // erroneous HAVE_ENOUGH_DATA just before HAVE_CURRENT_DATA state,\n            // hence keep trying to read it until resolved.\n            context.drawImage(element, 0, 0, width, height);\n          } catch (err) {}\n\n          tracking.trackCanvasInternal_(canvas, tracker);\n        }\n\n        requestAnimationFrame_();\n      });\n    };\n\n    var task = new tracking.TrackerTask(tracker);\n    task.on('stop', function () {\n      window.cancelAnimationFrame(requestId);\n    });\n    task.on('run', function () {\n      requestAnimationFrame_();\n    });\n    return task.run();\n  }; // Browser polyfills\n  //===================\n\n\n  if (!window.URL) {\n    window.URL = window.URL || window.webkitURL || window.msURL || window.oURL;\n  }\n\n  if (!navigator.getUserMedia) {\n    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n  }\n})(window);\n\n(function () {\n  /**\n   * EventEmitter utility.\n   * @constructor\n   */\n  tracking.EventEmitter = function () {};\n  /**\n   * Holds event listeners scoped by event type.\n   * @type {object}\n   * @private\n   */\n\n\n  tracking.EventEmitter.prototype.events_ = null;\n  /**\n   * Adds a listener to the end of the listeners array for the specified event.\n   * @param {string} event\n   * @param {function} listener\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n\n  tracking.EventEmitter.prototype.addListener = function (event, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('Listener must be a function');\n    }\n\n    if (!this.events_) {\n      this.events_ = {};\n    }\n\n    this.emit('newListener', event, listener);\n\n    if (!this.events_[event]) {\n      this.events_[event] = [];\n    }\n\n    this.events_[event].push(listener);\n    return this;\n  };\n  /**\n   * Returns an array of listeners for the specified event.\n   * @param {string} event\n   * @return {array} Array of listeners.\n   */\n\n\n  tracking.EventEmitter.prototype.listeners = function (event) {\n    return this.events_ && this.events_[event];\n  };\n  /**\n   * Execute each of the listeners in order with the supplied arguments.\n   * @param {string} event\n   * @param {*} opt_args [arg1], [arg2], [...]\n   * @return {boolean} Returns true if event had listeners, false otherwise.\n   */\n\n\n  tracking.EventEmitter.prototype.emit = function (event) {\n    var listeners = this.listeners(event);\n\n    if (listeners) {\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]) {\n          listeners[i].apply(this, args);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Adds a listener to the end of the listeners array for the specified event.\n   * @param {string} event\n   * @param {function} listener\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n\n\n  tracking.EventEmitter.prototype.on = tracking.EventEmitter.prototype.addListener;\n  /**\n   * Adds a one time listener for the event. This listener is invoked only the\n   * next time the event is fired, after which it is removed.\n   * @param {string} event\n   * @param {function} listener\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n\n  tracking.EventEmitter.prototype.once = function (event, listener) {\n    var self = this;\n    self.on(event, function handlerInternal() {\n      self.removeListener(event, handlerInternal);\n      listener.apply(this, arguments);\n    });\n  };\n  /**\n   * Removes all listeners, or those of the specified event. It's not a good\n   * idea to remove listeners that were added elsewhere in the code,\n   * especially when it's on an emitter that you didn't create.\n   * @param {string} event\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n\n\n  tracking.EventEmitter.prototype.removeAllListeners = function (opt_event) {\n    if (!this.events_) {\n      return this;\n    }\n\n    if (opt_event) {\n      delete this.events_[opt_event];\n    } else {\n      delete this.events_;\n    }\n\n    return this;\n  };\n  /**\n   * Remove a listener from the listener array for the specified event.\n   * Caution: changes array indices in the listener array behind the listener.\n   * @param {string} event\n   * @param {function} listener\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n\n\n  tracking.EventEmitter.prototype.removeListener = function (event, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('Listener must be a function');\n    }\n\n    if (!this.events_) {\n      return this;\n    }\n\n    var listeners = this.listeners(event);\n\n    if (Array.isArray(listeners)) {\n      var i = listeners.indexOf(listener);\n\n      if (i < 0) {\n        return this;\n      }\n\n      listeners.splice(i, 1);\n    }\n\n    return this;\n  };\n  /**\n   * By default EventEmitters will print a warning if more than 10 listeners\n   * are added for a particular event. This is a useful default which helps\n   * finding memory leaks. Obviously not all Emitters should be limited to 10.\n   * This function allows that to be increased. Set to zero for unlimited.\n   * @param {number} n The maximum number of listeners.\n   */\n\n\n  tracking.EventEmitter.prototype.setMaxListeners = function () {\n    throw new Error('Not implemented');\n  };\n})();\n\n(function () {\n  /**\n   * Canvas utility.\n   * @static\n   * @constructor\n   */\n  tracking.Canvas = {};\n  /**\n   * Loads an image source into the canvas.\n   * @param {HTMLCanvasElement} canvas The canvas dom element.\n   * @param {string} src The image source.\n   * @param {number} x The canvas horizontal coordinate to load the image.\n   * @param {number} y The canvas vertical coordinate to load the image.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {function} opt_callback Callback that fires when the image is loaded\n   *     into the canvas.\n   * @static\n   */\n\n  tracking.Canvas.loadImage = function (canvas, src, x, y, width, height, opt_callback) {\n    var instance = this;\n    var img = new window.Image();\n    img.crossOrigin = '*';\n\n    img.onload = function () {\n      var context = canvas.getContext('2d');\n      canvas.width = width;\n      canvas.height = height;\n      context.drawImage(img, x, y, width, height);\n\n      if (opt_callback) {\n        opt_callback.call(instance);\n      }\n\n      img = null;\n    };\n\n    img.src = src;\n  };\n})();\n\n(function () {\n  /**\n   * DisjointSet utility with path compression. Some applications involve\n   * grouping n distinct objects into a collection of disjoint sets. Two\n   * important operations are then finding which set a given object belongs to\n   * and uniting the two sets. A disjoint set data structure maintains a\n   * collection S={ S1 , S2 ,..., Sk } of disjoint dynamic sets. Each set is\n   * identified by a representative, which usually is a member in the set.\n   * @static\n   * @constructor\n   */\n  tracking.DisjointSet = function (length) {\n    if (length === undefined) {\n      throw new Error('DisjointSet length not specified.');\n    }\n\n    this.length = length;\n    this.parent = new Uint32Array(length);\n\n    for (var i = 0; i < length; i++) {\n      this.parent[i] = i;\n    }\n  };\n  /**\n   * Holds the length of the internal set.\n   * @type {number}\n   */\n\n\n  tracking.DisjointSet.prototype.length = null;\n  /**\n   * Holds the set containing the representative values.\n   * @type {Array.<number>}\n   */\n\n  tracking.DisjointSet.prototype.parent = null;\n  /**\n   * Finds a pointer to the representative of the set containing i.\n   * @param {number} i\n   * @return {number} The representative set of i.\n   */\n\n  tracking.DisjointSet.prototype.find = function (i) {\n    if (this.parent[i] === i) {\n      return i;\n    } else {\n      return this.parent[i] = this.find(this.parent[i]);\n    }\n  };\n  /**\n   * Unites two dynamic sets containing objects i and j, say Si and Sj, into\n   * a new set that Si ∪ Sj, assuming that Si ∩ Sj = ∅;\n   * @param {number} i\n   * @param {number} j\n   */\n\n\n  tracking.DisjointSet.prototype.union = function (i, j) {\n    var iRepresentative = this.find(i);\n    var jRepresentative = this.find(j);\n    this.parent[iRepresentative] = jRepresentative;\n  };\n})();\n\n(function () {\n  /**\n   * Image utility.\n   * @static\n   * @constructor\n   */\n  tracking.Image = {};\n  /**\n   * Computes gaussian blur. Adapted from\n   * https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {number} diameter Gaussian blur diameter, must be greater than 1.\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\n   */\n\n  tracking.Image.blur = function (pixels, width, height, diameter) {\n    diameter = Math.abs(diameter);\n\n    if (diameter <= 1) {\n      throw new Error('Diameter should be greater than 1.');\n    }\n\n    var radius = diameter / 2;\n    var len = Math.ceil(diameter) + (1 - Math.ceil(diameter) % 2);\n    var weights = new Float32Array(len);\n    var rho = (radius + 0.5) / 3;\n    var rhoSq = rho * rho;\n    var gaussianFactor = 1 / Math.sqrt(2 * Math.PI * rhoSq);\n    var rhoFactor = -1 / (2 * rho * rho);\n    var wsum = 0;\n    var middle = Math.floor(len / 2);\n\n    for (var i = 0; i < len; i++) {\n      var x = i - middle;\n      var gx = gaussianFactor * Math.exp(x * x * rhoFactor);\n      weights[i] = gx;\n      wsum += gx;\n    }\n\n    for (var j = 0; j < weights.length; j++) {\n      weights[j] /= wsum;\n    }\n\n    return this.separableConvolve(pixels, width, height, weights, weights, false);\n  };\n  /**\n   * Computes the integral image for summed, squared, rotated and sobel pixels.\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\n   *     through.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {array} opt_integralImage Empty array of size `width * height` to\n   *     be filled with the integral image values. If not specified compute sum\n   *     values will be skipped.\n   * @param {array} opt_integralImageSquare Empty array of size `width *\n   *     height` to be filled with the integral image squared values. If not\n   *     specified compute squared values will be skipped.\n   * @param {array} opt_tiltedIntegralImage Empty array of size `width *\n   *     height` to be filled with the rotated integral image values. If not\n   *     specified compute sum values will be skipped.\n   * @param {array} opt_integralImageSobel Empty array of size `width *\n   *     height` to be filled with the integral image of sobel values. If not\n   *     specified compute sobel filtering will be skipped.\n   * @static\n   */\n\n\n  tracking.Image.computeIntegralImage = function (pixels, width, height, opt_integralImage, opt_integralImageSquare, opt_tiltedIntegralImage, opt_integralImageSobel) {\n    if (arguments.length < 4) {\n      throw new Error('You should specify at least one output array in the order: sum, square, tilted, sobel.');\n    }\n\n    var pixelsSobel;\n\n    if (opt_integralImageSobel) {\n      pixelsSobel = tracking.Image.sobel(pixels, width, height);\n    }\n\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        var w = i * width * 4 + j * 4;\n        var pixel = ~~(pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114);\n\n        if (opt_integralImage) {\n          this.computePixelValueSAT_(opt_integralImage, width, i, j, pixel);\n        }\n\n        if (opt_integralImageSquare) {\n          this.computePixelValueSAT_(opt_integralImageSquare, width, i, j, pixel * pixel);\n        }\n\n        if (opt_tiltedIntegralImage) {\n          var w1 = w - width * 4;\n          var pixelAbove = ~~(pixels[w1] * 0.299 + pixels[w1 + 1] * 0.587 + pixels[w1 + 2] * 0.114);\n          this.computePixelValueRSAT_(opt_tiltedIntegralImage, width, i, j, pixel, pixelAbove || 0);\n        }\n\n        if (opt_integralImageSobel) {\n          this.computePixelValueSAT_(opt_integralImageSobel, width, i, j, pixelsSobel[w]);\n        }\n      }\n    }\n  };\n  /**\n   * Helper method to compute the rotated summed area table (RSAT) by the\n   * formula:\n   *\n   * RSAT(x, y) = RSAT(x-1, y-1) + RSAT(x+1, y-1) - RSAT(x, y-2) + I(x, y) + I(x, y-1)\n   *\n   * @param {number} width The image width.\n   * @param {array} RSAT Empty array of size `width * height` to be filled with\n   *     the integral image values. If not specified compute sum values will be\n   *     skipped.\n   * @param {number} i Vertical position of the pixel to be evaluated.\n   * @param {number} j Horizontal position of the pixel to be evaluated.\n   * @param {number} pixel Pixel value to be added to the integral image.\n   * @static\n   * @private\n   */\n\n\n  tracking.Image.computePixelValueRSAT_ = function (RSAT, width, i, j, pixel, pixelAbove) {\n    var w = i * width + j;\n    RSAT[w] = (RSAT[w - width - 1] || 0) + (RSAT[w - width + 1] || 0) - (RSAT[w - width - width] || 0) + pixel + pixelAbove;\n  };\n  /**\n   * Helper method to compute the summed area table (SAT) by the formula:\n   *\n   * SAT(x, y) = SAT(x, y-1) + SAT(x-1, y) + I(x, y) - SAT(x-1, y-1)\n   *\n   * @param {number} width The image width.\n   * @param {array} SAT Empty array of size `width * height` to be filled with\n   *     the integral image values. If not specified compute sum values will be\n   *     skipped.\n   * @param {number} i Vertical position of the pixel to be evaluated.\n   * @param {number} j Horizontal position of the pixel to be evaluated.\n   * @param {number} pixel Pixel value to be added to the integral image.\n   * @static\n   * @private\n   */\n\n\n  tracking.Image.computePixelValueSAT_ = function (SAT, width, i, j, pixel) {\n    var w = i * width + j;\n    SAT[w] = (SAT[w - width] || 0) + (SAT[w - 1] || 0) + pixel - (SAT[w - width - 1] || 0);\n  };\n  /**\n   * Converts a color from a colorspace based on an RGB color model to a\n   * grayscale representation of its luminance. The coefficients represent the\n   * measured intensity perception of typical trichromat humans, in\n   * particular, human vision is most sensitive to green and least sensitive\n   * to blue.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {boolean} fillRGBA If the result should fill all RGBA values with the gray scale\n   *  values, instead of returning a single value per pixel.\n   * @param {Uint8ClampedArray} The grayscale pixels in a linear array ([p,p,p,a,...] if fillRGBA\n   *  is true and [p1, p2, p3, ...] if fillRGBA is false).\n   * @static\n   */\n\n\n  tracking.Image.grayscale = function (pixels, width, height, fillRGBA) {\n    var gray = new Uint8ClampedArray(fillRGBA ? pixels.length : pixels.length >> 2);\n    var p = 0;\n    var w = 0;\n\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        var value = pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114;\n        gray[p++] = value;\n\n        if (fillRGBA) {\n          gray[p++] = value;\n          gray[p++] = value;\n          gray[p++] = pixels[w + 3];\n        }\n\n        w += 4;\n      }\n    }\n\n    return gray;\n  };\n  /**\n   * Fast horizontal separable convolution. A point spread function (PSF) is\n   * said to be separable if it can be broken into two one-dimensional\n   * signals: a vertical and a horizontal projection. The convolution is\n   * performed by sliding the kernel over the image, generally starting at the\n   * top left corner, so as to move the kernel through all the positions where\n   * the kernel fits entirely within the boundaries of the image. Adapted from\n   * https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\n   * @param {number} opaque\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\n   */\n\n\n  tracking.Image.horizontalConvolve = function (pixels, width, height, weightsVector, opaque) {\n    var side = weightsVector.length;\n    var halfSide = Math.floor(side / 2);\n    var output = new Float32Array(width * height * 4);\n    var alphaFac = opaque ? 1 : 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var sy = y;\n        var sx = x;\n        var offset = (y * width + x) * 4;\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        var a = 0;\n\n        for (var cx = 0; cx < side; cx++) {\n          var scy = sy;\n          var scx = Math.min(width - 1, Math.max(0, sx + cx - halfSide));\n          var poffset = (scy * width + scx) * 4;\n          var wt = weightsVector[cx];\n          r += pixels[poffset] * wt;\n          g += pixels[poffset + 1] * wt;\n          b += pixels[poffset + 2] * wt;\n          a += pixels[poffset + 3] * wt;\n        }\n\n        output[offset] = r;\n        output[offset + 1] = g;\n        output[offset + 2] = b;\n        output[offset + 3] = a + alphaFac * (255 - a);\n      }\n    }\n\n    return output;\n  };\n  /**\n   * Fast vertical separable convolution. A point spread function (PSF) is\n   * said to be separable if it can be broken into two one-dimensional\n   * signals: a vertical and a horizontal projection. The convolution is\n   * performed by sliding the kernel over the image, generally starting at the\n   * top left corner, so as to move the kernel through all the positions where\n   * the kernel fits entirely within the boundaries of the image. Adapted from\n   * https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\n   * @param {number} opaque\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\n   */\n\n\n  tracking.Image.verticalConvolve = function (pixels, width, height, weightsVector, opaque) {\n    var side = weightsVector.length;\n    var halfSide = Math.floor(side / 2);\n    var output = new Float32Array(width * height * 4);\n    var alphaFac = opaque ? 1 : 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var sy = y;\n        var sx = x;\n        var offset = (y * width + x) * 4;\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        var a = 0;\n\n        for (var cy = 0; cy < side; cy++) {\n          var scy = Math.min(height - 1, Math.max(0, sy + cy - halfSide));\n          var scx = sx;\n          var poffset = (scy * width + scx) * 4;\n          var wt = weightsVector[cy];\n          r += pixels[poffset] * wt;\n          g += pixels[poffset + 1] * wt;\n          b += pixels[poffset + 2] * wt;\n          a += pixels[poffset + 3] * wt;\n        }\n\n        output[offset] = r;\n        output[offset + 1] = g;\n        output[offset + 2] = b;\n        output[offset + 3] = a + alphaFac * (255 - a);\n      }\n    }\n\n    return output;\n  };\n  /**\n   * Fast separable convolution. A point spread function (PSF) is said to be\n   * separable if it can be broken into two one-dimensional signals: a\n   * vertical and a horizontal projection. The convolution is performed by\n   * sliding the kernel over the image, generally starting at the top left\n   * corner, so as to move the kernel through all the positions where the\n   * kernel fits entirely within the boundaries of the image. Adapted from\n   * https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {array} horizWeights The horizontal weighting vector, e.g [-1,0,1].\n   * @param {array} vertWeights The vertical vector, e.g [-1,0,1].\n   * @param {number} opaque\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\n   */\n\n\n  tracking.Image.separableConvolve = function (pixels, width, height, horizWeights, vertWeights, opaque) {\n    var vertical = this.verticalConvolve(pixels, width, height, vertWeights, opaque);\n    return this.horizontalConvolve(vertical, width, height, horizWeights, opaque);\n  };\n  /**\n   * Compute image edges using Sobel operator. Computes the vertical and\n   * horizontal gradients of the image and combines the computed images to\n   * find edges in the image. The way we implement the Sobel filter here is by\n   * first grayscaling the image, then taking the horizontal and vertical\n   * gradients and finally combining the gradient images to make up the final\n   * image. Adapted from https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\n   */\n\n\n  tracking.Image.sobel = function (pixels, width, height) {\n    pixels = this.grayscale(pixels, width, height, true);\n    var output = new Float32Array(width * height * 4);\n    var sobelSignVector = new Float32Array([-1, 0, 1]);\n    var sobelScaleVector = new Float32Array([1, 2, 1]);\n    var vertical = this.separableConvolve(pixels, width, height, sobelSignVector, sobelScaleVector);\n    var horizontal = this.separableConvolve(pixels, width, height, sobelScaleVector, sobelSignVector);\n\n    for (var i = 0; i < output.length; i += 4) {\n      var v = vertical[i];\n      var h = horizontal[i];\n      var p = Math.sqrt(h * h + v * v);\n      output[i] = p;\n      output[i + 1] = p;\n      output[i + 2] = p;\n      output[i + 3] = 255;\n    }\n\n    return output;\n  };\n})();\n\n(function () {\n  /**\n   * ViolaJones utility.\n   * @static\n   * @constructor\n   */\n  tracking.ViolaJones = {};\n  /**\n   * Holds the minimum area of intersection that defines when a rectangle is\n   * from the same group. Often when a face is matched multiple rectangles are\n   * classified as possible rectangles to represent the face, when they\n   * intersects they are grouped as one face.\n   * @type {number}\n   * @default 0.5\n   * @static\n   */\n\n  tracking.ViolaJones.REGIONS_OVERLAP = 0.5;\n  /**\n   * Holds the HAAR cascade classifiers converted from OpenCV training.\n   * @type {array}\n   * @static\n   */\n\n  tracking.ViolaJones.classifiers = {};\n  /**\n   * Detects through the HAAR cascade data rectangles matches.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {number} initialScale The initial scale to start the block\n   *     scaling.\n   * @param {number} scaleFactor The scale factor to scale the feature block.\n   * @param {number} stepSize The block step size.\n   * @param {number} edgesDensity Percentage density edges inside the\n   *     classifier block. Value from [0.0, 1.0], defaults to 0.2. If specified\n   *     edge detection will be applied to the image to prune dead areas of the\n   *     image, this can improve significantly performance.\n   * @param {number} data The HAAR cascade data.\n   * @return {array} Found rectangles.\n   * @static\n   */\n\n  tracking.ViolaJones.detect = function (pixels, width, height, initialScale, scaleFactor, stepSize, edgesDensity, data) {\n    var total = 0;\n    var rects = [];\n    var integralImage = new Int32Array(width * height);\n    var integralImageSquare = new Int32Array(width * height);\n    var tiltedIntegralImage = new Int32Array(width * height);\n    var integralImageSobel;\n\n    if (edgesDensity > 0) {\n      integralImageSobel = new Int32Array(width * height);\n    }\n\n    tracking.Image.computeIntegralImage(pixels, width, height, integralImage, integralImageSquare, tiltedIntegralImage, integralImageSobel);\n    var minWidth = data[0];\n    var minHeight = data[1];\n    var scale = initialScale * scaleFactor;\n    var blockWidth = scale * minWidth | 0;\n    var blockHeight = scale * minHeight | 0;\n\n    while (blockWidth < width && blockHeight < height) {\n      var step = scale * stepSize + 0.5 | 0;\n\n      for (var i = 0; i < height - blockHeight; i += step) {\n        for (var j = 0; j < width - blockWidth; j += step) {\n          if (edgesDensity > 0) {\n            if (this.isTriviallyExcluded(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight)) {\n              continue;\n            }\n          }\n\n          if (this.evalStages_(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale)) {\n            rects[total++] = {\n              width: blockWidth,\n              height: blockHeight,\n              x: j,\n              y: i\n            };\n          }\n        }\n      }\n\n      scale *= scaleFactor;\n      blockWidth = scale * minWidth | 0;\n      blockHeight = scale * minHeight | 0;\n    }\n\n    return this.mergeRectangles_(rects);\n  };\n  /**\n   * Fast check to test whether the edges density inside the block is greater\n   * than a threshold, if true it tests the stages. This can improve\n   * significantly performance.\n   * @param {number} edgesDensity Percentage density edges inside the\n   *     classifier block.\n   * @param {array} integralImageSobel The integral image of a sobel image.\n   * @param {number} i Vertical position of the pixel to be evaluated.\n   * @param {number} j Horizontal position of the pixel to be evaluated.\n   * @param {number} width The image width.\n   * @return {boolean} True whether the block at position i,j can be skipped,\n   *     false otherwise.\n   * @static\n   * @protected\n   */\n\n\n  tracking.ViolaJones.isTriviallyExcluded = function (edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight) {\n    var wbA = i * width + j;\n    var wbB = wbA + blockWidth;\n    var wbD = wbA + blockHeight * width;\n    var wbC = wbD + blockWidth;\n    var blockEdgesDensity = (integralImageSobel[wbA] - integralImageSobel[wbB] - integralImageSobel[wbD] + integralImageSobel[wbC]) / (blockWidth * blockHeight * 255);\n\n    if (blockEdgesDensity < edgesDensity) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Evaluates if the block size on i,j position is a valid HAAR cascade\n   * stage.\n   * @param {number} data The HAAR cascade data.\n   * @param {number} i Vertical position of the pixel to be evaluated.\n   * @param {number} j Horizontal position of the pixel to be evaluated.\n   * @param {number} width The image width.\n   * @param {number} blockSize The block size.\n   * @param {number} scale The scale factor of the block size and its original\n   *     size.\n   * @param {number} inverseArea The inverse area of the block size.\n   * @return {boolean} Whether the region passes all the stage tests.\n   * @private\n   * @static\n   */\n\n\n  tracking.ViolaJones.evalStages_ = function (data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale) {\n    var inverseArea = 1.0 / (blockWidth * blockHeight);\n    var wbA = i * width + j;\n    var wbB = wbA + blockWidth;\n    var wbD = wbA + blockHeight * width;\n    var wbC = wbD + blockWidth;\n    var mean = (integralImage[wbA] - integralImage[wbB] - integralImage[wbD] + integralImage[wbC]) * inverseArea;\n    var variance = (integralImageSquare[wbA] - integralImageSquare[wbB] - integralImageSquare[wbD] + integralImageSquare[wbC]) * inverseArea - mean * mean;\n    var standardDeviation = 1;\n\n    if (variance > 0) {\n      standardDeviation = Math.sqrt(variance);\n    }\n\n    var length = data.length;\n\n    for (var w = 2; w < length;) {\n      var stageSum = 0;\n      var stageThreshold = data[w++];\n      var nodeLength = data[w++];\n\n      while (nodeLength--) {\n        var rectsSum = 0;\n        var tilted = data[w++];\n        var rectsLength = data[w++];\n\n        for (var r = 0; r < rectsLength; r++) {\n          var rectLeft = j + data[w++] * scale + 0.5 | 0;\n          var rectTop = i + data[w++] * scale + 0.5 | 0;\n          var rectWidth = data[w++] * scale + 0.5 | 0;\n          var rectHeight = data[w++] * scale + 0.5 | 0;\n          var rectWeight = data[w++];\n          var w1;\n          var w2;\n          var w3;\n          var w4;\n\n          if (tilted) {\n            // RectSum(r) = RSAT(x-h+w, y+w+h-1) + RSAT(x, y-1) - RSAT(x-h, y+h-1) - RSAT(x+w, y+w-1)\n            w1 = rectLeft - rectHeight + rectWidth + (rectTop + rectWidth + rectHeight - 1) * width;\n            w2 = rectLeft + (rectTop - 1) * width;\n            w3 = rectLeft - rectHeight + (rectTop + rectHeight - 1) * width;\n            w4 = rectLeft + rectWidth + (rectTop + rectWidth - 1) * width;\n            rectsSum += (tiltedIntegralImage[w1] + tiltedIntegralImage[w2] - tiltedIntegralImage[w3] - tiltedIntegralImage[w4]) * rectWeight;\n          } else {\n            // RectSum(r) = SAT(x-1, y-1) + SAT(x+w-1, y+h-1) - SAT(x-1, y+h-1) - SAT(x+w-1, y-1)\n            w1 = rectTop * width + rectLeft;\n            w2 = w1 + rectWidth;\n            w3 = w1 + rectHeight * width;\n            w4 = w3 + rectWidth;\n            rectsSum += (integralImage[w1] - integralImage[w2] - integralImage[w3] + integralImage[w4]) * rectWeight; // TODO: Review the code below to analyze performance when using it instead.\n            // w1 = (rectLeft - 1) + (rectTop - 1) * width;\n            // w2 = (rectLeft + rectWidth - 1) + (rectTop + rectHeight - 1) * width;\n            // w3 = (rectLeft - 1) + (rectTop + rectHeight - 1) * width;\n            // w4 = (rectLeft + rectWidth - 1) + (rectTop - 1) * width;\n            // rectsSum += (integralImage[w1] + integralImage[w2] - integralImage[w3] - integralImage[w4]) * rectWeight;\n          }\n        }\n\n        var nodeThreshold = data[w++];\n        var nodeLeft = data[w++];\n        var nodeRight = data[w++];\n\n        if (rectsSum * inverseArea < nodeThreshold * standardDeviation) {\n          stageSum += nodeLeft;\n        } else {\n          stageSum += nodeRight;\n        }\n      }\n\n      if (stageSum < stageThreshold) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Postprocess the detected sub-windows in order to combine overlapping\n   * detections into a single detection.\n   * @param {array} rects\n   * @return {array}\n   * @private\n   * @static\n   */\n\n\n  tracking.ViolaJones.mergeRectangles_ = function (rects) {\n    var disjointSet = new tracking.DisjointSet(rects.length);\n\n    for (var i = 0; i < rects.length; i++) {\n      var r1 = rects[i];\n\n      for (var j = 0; j < rects.length; j++) {\n        var r2 = rects[j];\n\n        if (tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\n          var x1 = Math.max(r1.x, r2.x);\n          var y1 = Math.max(r1.y, r2.y);\n          var x2 = Math.min(r1.x + r1.width, r2.x + r2.width);\n          var y2 = Math.min(r1.y + r1.height, r2.y + r2.height);\n          var overlap = (x1 - x2) * (y1 - y2);\n          var area1 = r1.width * r1.height;\n          var area2 = r2.width * r2.height;\n\n          if (overlap / (area1 * (area1 / area2)) >= this.REGIONS_OVERLAP && overlap / (area2 * (area1 / area2)) >= this.REGIONS_OVERLAP) {\n            disjointSet.union(i, j);\n          }\n        }\n      }\n    }\n\n    var map = {};\n\n    for (var k = 0; k < disjointSet.length; k++) {\n      var rep = disjointSet.find(k);\n\n      if (!map[rep]) {\n        map[rep] = {\n          total: 1,\n          width: rects[k].width,\n          height: rects[k].height,\n          x: rects[k].x,\n          y: rects[k].y\n        };\n        continue;\n      }\n\n      map[rep].total++;\n      map[rep].width += rects[k].width;\n      map[rep].height += rects[k].height;\n      map[rep].x += rects[k].x;\n      map[rep].y += rects[k].y;\n    }\n\n    var result = [];\n    Object.keys(map).forEach(function (key) {\n      var rect = map[key];\n      result.push({\n        total: rect.total,\n        width: rect.width / rect.total + 0.5 | 0,\n        height: rect.height / rect.total + 0.5 | 0,\n        x: rect.x / rect.total + 0.5 | 0,\n        y: rect.y / rect.total + 0.5 | 0\n      });\n    });\n    return result;\n  };\n})();\n\n(function () {\n  /**\n   * Brief intends for \"Binary Robust Independent Elementary Features\".This\n   * method generates a binary string for each keypoint found by an extractor\n   * method.\n   * @static\n   * @constructor\n   */\n  tracking.Brief = {};\n  /**\n   * The set of binary tests is defined by the nd (x,y)-location pairs\n   * uniquely chosen during the initialization. Values could vary between N =\n   * 128,256,512. N=128 yield good compromises between speed, storage\n   * efficiency, and recognition rate.\n   * @type {number}\n   */\n\n  tracking.Brief.N = 512;\n  /**\n   * Caches coordinates values of (x,y)-location pairs uniquely chosen during\n   * the initialization.\n   * @type {Object.<number, Int32Array>}\n   * @private\n   * @static\n   */\n\n  tracking.Brief.randomImageOffsets_ = {};\n  /**\n   * Caches delta values of (x,y)-location pairs uniquely chosen during\n   * the initialization.\n   * @type {Int32Array}\n   * @private\n   * @static\n   */\n\n  tracking.Brief.randomWindowOffsets_ = null;\n  /**\n   * Generates a binary string for each found keypoints extracted using an\n   * extractor method.\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\n   * @param {number} width The image width.\n   * @param {array} keypoints\n   * @return {Int32Array} Returns an array where for each four sequence int\n   *     values represent the descriptor binary string (128 bits) necessary\n   *     to describe the corner, e.g. [0,0,0,0, 0,0,0,0, ...].\n   * @static\n   */\n\n  tracking.Brief.getDescriptors = function (pixels, width, keypoints) {\n    // Optimizing divide by 32 operation using binary shift\n    // (this.N >> 5) === this.N/32.\n    var descriptors = new Int32Array((keypoints.length >> 1) * (this.N >> 5));\n    var descriptorWord = 0;\n    var offsets = this.getRandomOffsets_(width);\n    var position = 0;\n\n    for (var i = 0; i < keypoints.length; i += 2) {\n      var w = width * keypoints[i + 1] + keypoints[i];\n      var offsetsPosition = 0;\n\n      for (var j = 0, n = this.N; j < n; j++) {\n        if (pixels[offsets[offsetsPosition++] + w] < pixels[offsets[offsetsPosition++] + w]) {\n          // The bit in the position `j % 32` of descriptorWord should be set to 1. We do\n          // this by making an OR operation with a binary number that only has the bit\n          // in that position set to 1. That binary number is obtained by shifting 1 left by\n          // `j % 32` (which is the same as `j & 31` left) positions.\n          descriptorWord |= 1 << (j & 31);\n        } // If the next j is a multiple of 32, we will need to use a new descriptor word to hold\n        // the next results.\n\n\n        if (!(j + 1 & 31)) {\n          descriptors[position++] = descriptorWord;\n          descriptorWord = 0;\n        }\n      }\n    }\n\n    return descriptors;\n  };\n  /**\n   * Matches sets of features {mi} and {m′j} extracted from two images taken\n   * from similar, and often successive, viewpoints. A classical procedure\n   * runs as follows. For each point {mi} in the first image, search in a\n   * region of the second image around location {mi} for point {m′j}. The\n   * search is based on the similarity of the local image windows, also known\n   * as kernel windows, centered on the points, which strongly characterizes\n   * the points when the images are sufficiently close. Once each keypoint is\n   * described with its binary string, they need to be compared with the\n   * closest matching point. Distance metric is critical to the performance of\n   * in- trusion detection systems. Thus using binary strings reduces the size\n   * of the descriptor and provides an interesting data structure that is fast\n   * to operate whose similarity can be measured by the Hamming distance.\n   * @param {array} keypoints1\n   * @param {array} descriptors1\n   * @param {array} keypoints2\n   * @param {array} descriptors2\n   * @return {Int32Array} Returns an array where the index is the corner1\n   *     index coordinate, and the value is the corresponding match index of\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\n   *     the return array would be [3,0].\n   * @static\n   */\n\n\n  tracking.Brief.match = function (keypoints1, descriptors1, keypoints2, descriptors2) {\n    var len1 = keypoints1.length >> 1;\n    var len2 = keypoints2.length >> 1;\n    var matches = new Array(len1);\n\n    for (var i = 0; i < len1; i++) {\n      var min = Infinity;\n      var minj = 0;\n\n      for (var j = 0; j < len2; j++) {\n        var dist = 0; // Optimizing divide by 32 operation using binary shift\n        // (this.N >> 5) === this.N/32.\n\n        for (var k = 0, n = this.N >> 5; k < n; k++) {\n          dist += tracking.Math.hammingWeight(descriptors1[i * n + k] ^ descriptors2[j * n + k]);\n        }\n\n        if (dist < min) {\n          min = dist;\n          minj = j;\n        }\n      }\n\n      matches[i] = {\n        index1: i,\n        index2: minj,\n        keypoint1: [keypoints1[2 * i], keypoints1[2 * i + 1]],\n        keypoint2: [keypoints2[2 * minj], keypoints2[2 * minj + 1]],\n        confidence: 1 - min / this.N\n      };\n    }\n\n    return matches;\n  };\n  /**\n   * Removes matches outliers by testing matches on both directions.\n   * @param {array} keypoints1\n   * @param {array} descriptors1\n   * @param {array} keypoints2\n   * @param {array} descriptors2\n   * @return {Int32Array} Returns an array where the index is the corner1\n   *     index coordinate, and the value is the corresponding match index of\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\n   *     the return array would be [3,0].\n   * @static\n   */\n\n\n  tracking.Brief.reciprocalMatch = function (keypoints1, descriptors1, keypoints2, descriptors2) {\n    var matches = [];\n\n    if (keypoints1.length === 0 || keypoints2.length === 0) {\n      return matches;\n    }\n\n    var matches1 = tracking.Brief.match(keypoints1, descriptors1, keypoints2, descriptors2);\n    var matches2 = tracking.Brief.match(keypoints2, descriptors2, keypoints1, descriptors1);\n\n    for (var i = 0; i < matches1.length; i++) {\n      if (matches2[matches1[i].index2].index2 === i) {\n        matches.push(matches1[i]);\n      }\n    }\n\n    return matches;\n  };\n  /**\n   * Gets the coordinates values of (x,y)-location pairs uniquely chosen\n   * during the initialization.\n   * @return {array} Array with the random offset values.\n   * @private\n   */\n\n\n  tracking.Brief.getRandomOffsets_ = function (width) {\n    if (!this.randomWindowOffsets_) {\n      var windowPosition = 0;\n      var windowOffsets = new Int32Array(4 * this.N);\n\n      for (var i = 0; i < this.N; i++) {\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\n      }\n\n      this.randomWindowOffsets_ = windowOffsets;\n    }\n\n    if (!this.randomImageOffsets_[width]) {\n      var imagePosition = 0;\n      var imageOffsets = new Int32Array(2 * this.N);\n\n      for (var j = 0; j < this.N; j++) {\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j] * width + this.randomWindowOffsets_[4 * j + 1];\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j + 2] * width + this.randomWindowOffsets_[4 * j + 3];\n      }\n\n      this.randomImageOffsets_[width] = imageOffsets;\n    }\n\n    return this.randomImageOffsets_[width];\n  };\n})();\n\n(function () {\n  /**\n   * FAST intends for \"Features from Accelerated Segment Test\". This method\n   * performs a point segment test corner detection. The segment test\n   * criterion operates by considering a circle of sixteen pixels around the\n   * corner candidate p. The detector classifies p as a corner if there exists\n   * a set of n contiguous pixelsin the circle which are all brighter than the\n   * intensity of the candidate pixel Ip plus a threshold t, or all darker\n   * than Ip − t.\n   *\n   *       15 00 01\n   *    14          02\n   * 13                03\n   * 12       []       04\n   * 11                05\n   *    10          06\n   *       09 08 07\n   *\n   * For more reference:\n   * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.3991&rep=rep1&type=pdf\n   * @static\n   * @constructor\n   */\n  tracking.Fast = {};\n  /**\n   * Holds the threshold to determine whether the tested pixel is brighter or\n   * darker than the corner candidate p.\n   * @type {number}\n   * @default 40\n   * @static\n   */\n\n  tracking.Fast.THRESHOLD = 40;\n  /**\n   * Caches coordinates values of the circle surrounding the pixel candidate p.\n   * @type {Object.<number, Int32Array>}\n   * @private\n   * @static\n   */\n\n  tracking.Fast.circles_ = {};\n  /**\n   * Finds corners coordinates on the graysacaled image.\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {number} threshold to determine whether the tested pixel is brighter or\n   *     darker than the corner candidate p. Default value is 40.\n   * @return {array} Array containing the coordinates of all found corners,\n   *     e.g. [x0,y0,x1,y1,...], where P(x0,y0) represents a corner coordinate.\n   * @static\n   */\n\n  tracking.Fast.findCorners = function (pixels, width, height, opt_threshold) {\n    var circleOffsets = this.getCircleOffsets_(width);\n    var circlePixels = new Int32Array(16);\n    var corners = [];\n\n    if (opt_threshold === undefined) {\n      opt_threshold = this.THRESHOLD;\n    } // When looping through the image pixels, skips the first three lines from\n    // the image boundaries to constrain the surrounding circle inside the image\n    // area.\n\n\n    for (var i = 3; i < height - 3; i++) {\n      for (var j = 3; j < width - 3; j++) {\n        var w = i * width + j;\n        var p = pixels[w]; // Loops the circle offsets to read the pixel value for the sixteen\n        // surrounding pixels.\n\n        for (var k = 0; k < 16; k++) {\n          circlePixels[k] = pixels[w + circleOffsets[k]];\n        }\n\n        if (this.isCorner(p, circlePixels, opt_threshold)) {\n          // The pixel p is classified as a corner, as optimization increment j\n          // by the circle radius 3 to skip the neighbor pixels inside the\n          // surrounding circle. This can be removed without compromising the\n          // result.\n          corners.push(j, i);\n          j += 3;\n        }\n      }\n    }\n\n    return corners;\n  };\n  /**\n   * Checks if the circle pixel is brighter than the candidate pixel p by\n   * a threshold.\n   * @param {number} circlePixel The circle pixel value.\n   * @param {number} p The value of the candidate pixel p.\n   * @param {number} threshold\n   * @return {Boolean}\n   * @static\n   */\n\n\n  tracking.Fast.isBrighter = function (circlePixel, p, threshold) {\n    return circlePixel - p > threshold;\n  };\n  /**\n   * Checks if the circle pixel is within the corner of the candidate pixel p\n   * by a threshold.\n   * @param {number} p The value of the candidate pixel p.\n   * @param {number} circlePixel The circle pixel value.\n   * @param {number} threshold\n   * @return {Boolean}\n   * @static\n   */\n\n\n  tracking.Fast.isCorner = function (p, circlePixels, threshold) {\n    if (this.isTriviallyExcluded(circlePixels, p, threshold)) {\n      return false;\n    }\n\n    for (var x = 0; x < 16; x++) {\n      var darker = true;\n      var brighter = true;\n\n      for (var y = 0; y < 9; y++) {\n        var circlePixel = circlePixels[x + y & 15];\n\n        if (!this.isBrighter(p, circlePixel, threshold)) {\n          brighter = false;\n\n          if (darker === false) {\n            break;\n          }\n        }\n\n        if (!this.isDarker(p, circlePixel, threshold)) {\n          darker = false;\n\n          if (brighter === false) {\n            break;\n          }\n        }\n      }\n\n      if (brighter || darker) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Checks if the circle pixel is darker than the candidate pixel p by\n   * a threshold.\n   * @param {number} circlePixel The circle pixel value.\n   * @param {number} p The value of the candidate pixel p.\n   * @param {number} threshold\n   * @return {Boolean}\n   * @static\n   */\n\n\n  tracking.Fast.isDarker = function (circlePixel, p, threshold) {\n    return p - circlePixel > threshold;\n  };\n  /**\n   * Fast check to test if the candidate pixel is a trivially excluded value.\n   * In order to be a corner, the candidate pixel value should be darker or\n   * brighter than 9-12 surrounding pixels, when at least three of the top,\n   * bottom, left and right pixels are brighter or darker it can be\n   * automatically excluded improving the performance.\n   * @param {number} circlePixel The circle pixel value.\n   * @param {number} p The value of the candidate pixel p.\n   * @param {number} threshold\n   * @return {Boolean}\n   * @static\n   * @protected\n   */\n\n\n  tracking.Fast.isTriviallyExcluded = function (circlePixels, p, threshold) {\n    var count = 0;\n    var circleBottom = circlePixels[8];\n    var circleLeft = circlePixels[12];\n    var circleRight = circlePixels[4];\n    var circleTop = circlePixels[0];\n\n    if (this.isBrighter(circleTop, p, threshold)) {\n      count++;\n    }\n\n    if (this.isBrighter(circleRight, p, threshold)) {\n      count++;\n    }\n\n    if (this.isBrighter(circleBottom, p, threshold)) {\n      count++;\n    }\n\n    if (this.isBrighter(circleLeft, p, threshold)) {\n      count++;\n    }\n\n    if (count < 3) {\n      count = 0;\n\n      if (this.isDarker(circleTop, p, threshold)) {\n        count++;\n      }\n\n      if (this.isDarker(circleRight, p, threshold)) {\n        count++;\n      }\n\n      if (this.isDarker(circleBottom, p, threshold)) {\n        count++;\n      }\n\n      if (this.isDarker(circleLeft, p, threshold)) {\n        count++;\n      }\n\n      if (count < 3) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Gets the sixteen offset values of the circle surrounding pixel.\n   * @param {number} width The image width.\n   * @return {array} Array with the sixteen offset values of the circle\n   *     surrounding pixel.\n   * @private\n   */\n\n\n  tracking.Fast.getCircleOffsets_ = function (width) {\n    if (this.circles_[width]) {\n      return this.circles_[width];\n    }\n\n    var circle = new Int32Array(16);\n    circle[0] = -width - width - width;\n    circle[1] = circle[0] + 1;\n    circle[2] = circle[1] + width + 1;\n    circle[3] = circle[2] + width + 1;\n    circle[4] = circle[3] + width;\n    circle[5] = circle[4] + width;\n    circle[6] = circle[5] + width - 1;\n    circle[7] = circle[6] + width - 1;\n    circle[8] = circle[7] - 1;\n    circle[9] = circle[8] - 1;\n    circle[10] = circle[9] - width - 1;\n    circle[11] = circle[10] - width - 1;\n    circle[12] = circle[11] - width;\n    circle[13] = circle[12] - width;\n    circle[14] = circle[13] - width + 1;\n    circle[15] = circle[14] - width + 1;\n    this.circles_[width] = circle;\n    return circle;\n  };\n})();\n\n(function () {\n  /**\n   * Math utility.\n   * @static\n   * @constructor\n   */\n  tracking.Math = {};\n  /**\n   * Euclidean distance between two points P(x0, y0) and P(x1, y1).\n   * @param {number} x0 Horizontal coordinate of P0.\n   * @param {number} y0 Vertical coordinate of P0.\n   * @param {number} x1 Horizontal coordinate of P1.\n   * @param {number} y1 Vertical coordinate of P1.\n   * @return {number} The euclidean distance.\n   */\n\n  tracking.Math.distance = function (x0, y0, x1, y1) {\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n  /**\n   * Calculates the Hamming weight of a string, which is the number of symbols that are\n   * different from the zero-symbol of the alphabet used. It is thus\n   * equivalent to the Hamming distance from the all-zero string of the same\n   * length. For the most typical case, a string of bits, this is the number\n   * of 1's in the string.\n   *\n   * Example:\n   *\n   * <pre>\n   *  Binary string     Hamming weight\n   *   11101                 4\n   *   11101010              5\n   * </pre>\n   *\n   * @param {number} i Number that holds the binary string to extract the hamming weight.\n   * @return {number} The hamming weight.\n   */\n\n\n  tracking.Math.hammingWeight = function (i) {\n    i = i - (i >> 1 & 0x55555555);\n    i = (i & 0x33333333) + (i >> 2 & 0x33333333);\n    return (i + (i >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n  };\n  /**\n   * Generates a random number between [a, b] interval.\n   * @param {number} a\n   * @param {number} b\n   * @return {number}\n   */\n\n\n  tracking.Math.uniformRandom = function (a, b) {\n    return a + Math.random() * (b - a);\n  };\n  /**\n   * Tests if a rectangle intersects with another.\n   *\n   *  <pre>\n   *  x0y0 --------       x2y2 --------\n   *      |       |           |       |\n   *      -------- x1y1       -------- x3y3\n   * </pre>\n   *\n   * @param {number} x0 Horizontal coordinate of P0.\n   * @param {number} y0 Vertical coordinate of P0.\n   * @param {number} x1 Horizontal coordinate of P1.\n   * @param {number} y1 Vertical coordinate of P1.\n   * @param {number} x2 Horizontal coordinate of P2.\n   * @param {number} y2 Vertical coordinate of P2.\n   * @param {number} x3 Horizontal coordinate of P3.\n   * @param {number} y3 Vertical coordinate of P3.\n   * @return {boolean}\n   */\n\n\n  tracking.Math.intersectRect = function (x0, y0, x1, y1, x2, y2, x3, y3) {\n    return !(x2 > x1 || x3 < x0 || y2 > y1 || y3 < y0);\n  };\n})();\n\n(function () {\n  /**\n   * Matrix utility.\n   * @static\n   * @constructor\n   */\n  tracking.Matrix = {};\n  /**\n   * Loops the array organized as major-row order and executes `fn` callback\n   * for each iteration. The `fn` callback receives the following parameters:\n   * `(r,g,b,a,index,i,j)`, where `r,g,b,a` represents the pixel color with\n   * alpha channel, `index` represents the position in the major-row order\n   * array and `i,j` the respective indexes positions in two dimensions.\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\n   *     through.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {function} fn The callback function for each pixel.\n   * @param {number} opt_jump Optional jump for the iteration, by default it\n   *     is 1, hence loops all the pixels of the array.\n   * @static\n   */\n\n  tracking.Matrix.forEach = function (pixels, width, height, fn, opt_jump) {\n    opt_jump = opt_jump || 1;\n\n    for (var i = 0; i < height; i += opt_jump) {\n      for (var j = 0; j < width; j += opt_jump) {\n        var w = i * width * 4 + j * 4;\n        fn.call(this, pixels[w], pixels[w + 1], pixels[w + 2], pixels[w + 3], w, i, j);\n      }\n    }\n  };\n})();\n\n(function () {\n  /**\n   * EPnp utility.\n   * @static\n   * @constructor\n   */\n  tracking.EPnP = {};\n\n  tracking.EPnP.solve = function (objectPoints, imagePoints, cameraMatrix) {};\n})();\n\n(function () {\n  /**\n   * Tracker utility.\n   * @constructor\n   * @extends {tracking.EventEmitter}\n   */\n  tracking.Tracker = function () {\n    tracking.Tracker.base(this, 'constructor');\n  };\n\n  tracking.inherits(tracking.Tracker, tracking.EventEmitter);\n  /**\n   * Tracks the pixels on the array. This method is called for each video\n   * frame in order to emit `track` event.\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\n   * @param {number} width The pixels canvas width.\n   * @param {number} height The pixels canvas height.\n   */\n\n  tracking.Tracker.prototype.track = function () {};\n})();\n\n(function () {\n  /**\n   * TrackerTask utility.\n   * @constructor\n   * @extends {tracking.EventEmitter}\n   */\n  tracking.TrackerTask = function (tracker) {\n    tracking.TrackerTask.base(this, 'constructor');\n\n    if (!tracker) {\n      throw new Error('Tracker instance not specified.');\n    }\n\n    this.setTracker(tracker);\n  };\n\n  tracking.inherits(tracking.TrackerTask, tracking.EventEmitter);\n  /**\n   * Holds the tracker instance managed by this task.\n   * @type {tracking.Tracker}\n   * @private\n   */\n\n  tracking.TrackerTask.prototype.tracker_ = null;\n  /**\n   * Holds if the tracker task is in running.\n   * @type {boolean}\n   * @private\n   */\n\n  tracking.TrackerTask.prototype.running_ = false;\n  /**\n   * Gets the tracker instance managed by this task.\n   * @return {tracking.Tracker}\n   */\n\n  tracking.TrackerTask.prototype.getTracker = function () {\n    return this.tracker_;\n  };\n  /**\n   * Returns true if the tracker task is in running, false otherwise.\n   * @return {boolean}\n   * @private\n   */\n\n\n  tracking.TrackerTask.prototype.inRunning = function () {\n    return this.running_;\n  };\n  /**\n   * Sets if the tracker task is in running.\n   * @param {boolean} running\n   * @private\n   */\n\n\n  tracking.TrackerTask.prototype.setRunning = function (running) {\n    this.running_ = running;\n  };\n  /**\n   * Sets the tracker instance managed by this task.\n   * @return {tracking.Tracker}\n   */\n\n\n  tracking.TrackerTask.prototype.setTracker = function (tracker) {\n    this.tracker_ = tracker;\n  };\n  /**\n   * Emits a `run` event on the tracker task for the implementers to run any\n   * child action, e.g. `requestAnimationFrame`.\n   * @return {object} Returns itself, so calls can be chained.\n   */\n\n\n  tracking.TrackerTask.prototype.run = function () {\n    var self = this;\n\n    if (this.inRunning()) {\n      return;\n    }\n\n    this.setRunning(true);\n\n    this.reemitTrackEvent_ = function (event) {\n      self.emit('track', event);\n    };\n\n    this.tracker_.on('track', this.reemitTrackEvent_);\n    this.emit('run');\n    return this;\n  };\n  /**\n   * Emits a `stop` event on the tracker task for the implementers to stop any\n   * child action being done, e.g. `requestAnimationFrame`.\n   * @return {object} Returns itself, so calls can be chained.\n   */\n\n\n  tracking.TrackerTask.prototype.stop = function () {\n    if (!this.inRunning()) {\n      return;\n    }\n\n    this.setRunning(false);\n    this.emit('stop');\n    this.tracker_.removeListener('track', this.reemitTrackEvent_);\n    return this;\n  };\n})();\n\n(function () {\n  /**\n   * ColorTracker utility to track colored blobs in a frame using color\n   * difference evaluation.\n   * @constructor\n   * @param {string|Array.<string>} opt_colors Optional colors to track.\n   * @extends {tracking.Tracker}\n   */\n  tracking.ColorTracker = function (opt_colors) {\n    tracking.ColorTracker.base(this, 'constructor');\n\n    if (typeof opt_colors === 'string') {\n      opt_colors = [opt_colors];\n    }\n\n    if (opt_colors) {\n      opt_colors.forEach(function (color) {\n        if (!tracking.ColorTracker.getColor(color)) {\n          throw new Error('Color not valid, try `new tracking.ColorTracker(\"magenta\")`.');\n        }\n      });\n      this.setColors(opt_colors);\n    }\n  };\n\n  tracking.inherits(tracking.ColorTracker, tracking.Tracker);\n  /**\n   * Holds the known colors.\n   * @type {Object.<string, function>}\n   * @private\n   * @static\n   */\n\n  tracking.ColorTracker.knownColors_ = {};\n  /**\n   * Caches coordinates values of the neighbours surrounding a pixel.\n   * @type {Object.<number, Int32Array>}\n   * @private\n   * @static\n   */\n\n  tracking.ColorTracker.neighbours_ = {};\n  /**\n   * Registers a color as known color.\n   * @param {string} name The color name.\n   * @param {function} fn The color function to test if the passed (r,g,b) is\n   *     the desired color.\n   * @static\n   */\n\n  tracking.ColorTracker.registerColor = function (name, fn) {\n    tracking.ColorTracker.knownColors_[name] = fn;\n  };\n  /**\n   * Gets the known color function that is able to test whether an (r,g,b) is\n   * the desired color.\n   * @param {string} name The color name.\n   * @return {function} The known color test function.\n   * @static\n   */\n\n\n  tracking.ColorTracker.getColor = function (name) {\n    return tracking.ColorTracker.knownColors_[name];\n  };\n  /**\n   * Holds the colors to be tracked by the `ColorTracker` instance.\n   * @default ['magenta']\n   * @type {Array.<string>}\n   */\n\n\n  tracking.ColorTracker.prototype.colors = ['magenta'];\n  /**\n   * Holds the minimum dimension to classify a rectangle.\n   * @default 20\n   * @type {number}\n   */\n\n  tracking.ColorTracker.prototype.minDimension = 20;\n  /**\n   * Holds the maximum dimension to classify a rectangle.\n   * @default Infinity\n   * @type {number}\n   */\n\n  tracking.ColorTracker.prototype.maxDimension = Infinity;\n  /**\n   * Holds the minimum group size to be classified as a rectangle.\n   * @default 30\n   * @type {number}\n   */\n\n  tracking.ColorTracker.prototype.minGroupSize = 30;\n  /**\n   * Calculates the central coordinate from the cloud points. The cloud points\n   * are all points that matches the desired color.\n   * @param {Array.<number>} cloud Major row order array containing all the\n   *     points from the desired color, e.g. [x1, y1, c2, y2, ...].\n   * @param {number} total Total numbers of pixels of the desired color.\n   * @return {object} Object containing the x, y and estimated z coordinate of\n   *     the blog extracted from the cloud points.\n   * @private\n   */\n\n  tracking.ColorTracker.prototype.calculateDimensions_ = function (cloud, total) {\n    var maxx = -1;\n    var maxy = -1;\n    var minx = Infinity;\n    var miny = Infinity;\n\n    for (var c = 0; c < total; c += 2) {\n      var x = cloud[c];\n      var y = cloud[c + 1];\n\n      if (x < minx) {\n        minx = x;\n      }\n\n      if (x > maxx) {\n        maxx = x;\n      }\n\n      if (y < miny) {\n        miny = y;\n      }\n\n      if (y > maxy) {\n        maxy = y;\n      }\n    }\n\n    return {\n      width: maxx - minx,\n      height: maxy - miny,\n      x: minx,\n      y: miny\n    };\n  };\n  /**\n   * Gets the colors being tracked by the `ColorTracker` instance.\n   * @return {Array.<string>}\n   */\n\n\n  tracking.ColorTracker.prototype.getColors = function () {\n    return this.colors;\n  };\n  /**\n   * Gets the minimum dimension to classify a rectangle.\n   * @return {number}\n   */\n\n\n  tracking.ColorTracker.prototype.getMinDimension = function () {\n    return this.minDimension;\n  };\n  /**\n   * Gets the maximum dimension to classify a rectangle.\n   * @return {number}\n   */\n\n\n  tracking.ColorTracker.prototype.getMaxDimension = function () {\n    return this.maxDimension;\n  };\n  /**\n   * Gets the minimum group size to be classified as a rectangle.\n   * @return {number}\n   */\n\n\n  tracking.ColorTracker.prototype.getMinGroupSize = function () {\n    return this.minGroupSize;\n  };\n  /**\n   * Gets the eight offset values of the neighbours surrounding a pixel.\n   * @param {number} width The image width.\n   * @return {array} Array with the eight offset values of the neighbours\n   *     surrounding a pixel.\n   * @private\n   */\n\n\n  tracking.ColorTracker.prototype.getNeighboursForWidth_ = function (width) {\n    if (tracking.ColorTracker.neighbours_[width]) {\n      return tracking.ColorTracker.neighbours_[width];\n    }\n\n    var neighbours = new Int32Array(8);\n    neighbours[0] = -width * 4;\n    neighbours[1] = -width * 4 + 4;\n    neighbours[2] = 4;\n    neighbours[3] = width * 4 + 4;\n    neighbours[4] = width * 4;\n    neighbours[5] = width * 4 - 4;\n    neighbours[6] = -4;\n    neighbours[7] = -width * 4 - 4;\n    tracking.ColorTracker.neighbours_[width] = neighbours;\n    return neighbours;\n  };\n  /**\n   * Unites groups whose bounding box intersect with each other.\n   * @param {Array.<Object>} rects\n   * @private\n   */\n\n\n  tracking.ColorTracker.prototype.mergeRectangles_ = function (rects) {\n    var intersects;\n    var results = [];\n    var minDimension = this.getMinDimension();\n    var maxDimension = this.getMaxDimension();\n\n    for (var r = 0; r < rects.length; r++) {\n      var r1 = rects[r];\n      intersects = true;\n\n      for (var s = r + 1; s < rects.length; s++) {\n        var r2 = rects[s];\n\n        if (tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\n          intersects = false;\n          var x1 = Math.min(r1.x, r2.x);\n          var y1 = Math.min(r1.y, r2.y);\n          var x2 = Math.max(r1.x + r1.width, r2.x + r2.width);\n          var y2 = Math.max(r1.y + r1.height, r2.y + r2.height);\n          r2.height = y2 - y1;\n          r2.width = x2 - x1;\n          r2.x = x1;\n          r2.y = y1;\n          break;\n        }\n      }\n\n      if (intersects) {\n        if (r1.width >= minDimension && r1.height >= minDimension) {\n          if (r1.width <= maxDimension && r1.height <= maxDimension) {\n            results.push(r1);\n          }\n        }\n      }\n    }\n\n    return results;\n  };\n  /**\n   * Sets the colors to be tracked by the `ColorTracker` instance.\n   * @param {Array.<string>} colors\n   */\n\n\n  tracking.ColorTracker.prototype.setColors = function (colors) {\n    this.colors = colors;\n  };\n  /**\n   * Sets the minimum dimension to classify a rectangle.\n   * @param {number} minDimension\n   */\n\n\n  tracking.ColorTracker.prototype.setMinDimension = function (minDimension) {\n    this.minDimension = minDimension;\n  };\n  /**\n   * Sets the maximum dimension to classify a rectangle.\n   * @param {number} maxDimension\n   */\n\n\n  tracking.ColorTracker.prototype.setMaxDimension = function (maxDimension) {\n    this.maxDimension = maxDimension;\n  };\n  /**\n   * Sets the minimum group size to be classified as a rectangle.\n   * @param {number} minGroupSize\n   */\n\n\n  tracking.ColorTracker.prototype.setMinGroupSize = function (minGroupSize) {\n    this.minGroupSize = minGroupSize;\n  };\n  /**\n   * Tracks the `Video` frames. This method is called for each video frame in\n   * order to emit `track` event.\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\n   * @param {number} width The pixels canvas width.\n   * @param {number} height The pixels canvas height.\n   */\n\n\n  tracking.ColorTracker.prototype.track = function (pixels, width, height) {\n    var self = this;\n    var colors = this.getColors();\n\n    if (!colors) {\n      throw new Error('Colors not specified, try `new tracking.ColorTracker(\"magenta\")`.');\n    }\n\n    var results = [];\n    colors.forEach(function (color) {\n      results = results.concat(self.trackColor_(pixels, width, height, color));\n    });\n    this.emit('track', {\n      data: results\n    });\n  };\n  /**\n   * Find the given color in the given matrix of pixels using Flood fill\n   * algorithm to determines the area connected to a given node in a\n   * multi-dimensional array.\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\n   * @param {number} width The pixels canvas width.\n   * @param {number} height The pixels canvas height.\n   * @param {string} color The color to be found\n   * @private\n   */\n\n\n  tracking.ColorTracker.prototype.trackColor_ = function (pixels, width, height, color) {\n    var colorFn = tracking.ColorTracker.knownColors_[color];\n    var currGroup = new Int32Array(pixels.length >> 2);\n    var currGroupSize;\n    var currI;\n    var currJ;\n    var currW;\n    var marked = new Int8Array(pixels.length);\n    var minGroupSize = this.getMinGroupSize();\n    var neighboursW = this.getNeighboursForWidth_(width);\n    var queue = new Int32Array(pixels.length);\n    var queuePosition;\n    var results = [];\n    var w = -4;\n\n    if (!colorFn) {\n      return results;\n    }\n\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        w += 4;\n\n        if (marked[w]) {\n          continue;\n        }\n\n        currGroupSize = 0;\n        queuePosition = -1;\n        queue[++queuePosition] = w;\n        queue[++queuePosition] = i;\n        queue[++queuePosition] = j;\n        marked[w] = 1;\n\n        while (queuePosition >= 0) {\n          currJ = queue[queuePosition--];\n          currI = queue[queuePosition--];\n          currW = queue[queuePosition--];\n\n          if (colorFn(pixels[currW], pixels[currW + 1], pixels[currW + 2], pixels[currW + 3], currW, currI, currJ)) {\n            currGroup[currGroupSize++] = currJ;\n            currGroup[currGroupSize++] = currI;\n\n            for (var k = 0; k < neighboursW.length; k++) {\n              var otherW = currW + neighboursW[k];\n              var otherI = currI + neighboursI[k];\n              var otherJ = currJ + neighboursJ[k];\n\n              if (!marked[otherW] && otherI >= 0 && otherI < height && otherJ >= 0 && otherJ < width) {\n                queue[++queuePosition] = otherW;\n                queue[++queuePosition] = otherI;\n                queue[++queuePosition] = otherJ;\n                marked[otherW] = 1;\n              }\n            }\n          }\n        }\n\n        if (currGroupSize >= minGroupSize) {\n          var data = this.calculateDimensions_(currGroup, currGroupSize);\n\n          if (data) {\n            data.color = color;\n            results.push(data);\n          }\n        }\n      }\n    }\n\n    return this.mergeRectangles_(results);\n  }; // Default colors\n  //===================\n\n\n  tracking.ColorTracker.registerColor('cyan', function (r, g, b) {\n    var thresholdGreen = 50,\n        thresholdBlue = 70,\n        dx = r - 0,\n        dy = g - 255,\n        dz = b - 255;\n\n    if (g - r >= thresholdGreen && b - r >= thresholdBlue) {\n      return true;\n    }\n\n    return dx * dx + dy * dy + dz * dz < 6400;\n  });\n  tracking.ColorTracker.registerColor('magenta', function (r, g, b) {\n    var threshold = 50,\n        dx = r - 255,\n        dy = g - 0,\n        dz = b - 255;\n\n    if (r - g >= threshold && b - g >= threshold) {\n      return true;\n    }\n\n    return dx * dx + dy * dy + dz * dz < 19600;\n  });\n  tracking.ColorTracker.registerColor('yellow', function (r, g, b) {\n    var threshold = 50,\n        dx = r - 255,\n        dy = g - 255,\n        dz = b - 0;\n\n    if (r - b >= threshold && g - b >= threshold) {\n      return true;\n    }\n\n    return dx * dx + dy * dy + dz * dz < 10000;\n  }); // Caching neighbour i/j offset values.\n  //=====================================\n\n  var neighboursI = new Int32Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n  var neighboursJ = new Int32Array([0, 1, 1, 1, 0, -1, -1, -1]);\n})();\n\n(function () {\n  /**\n   * ObjectTracker utility.\n   * @constructor\n   * @param {string|Array.<string|Array.<number>>} opt_classifiers Optional\n   *     object classifiers to track.\n   * @extends {tracking.Tracker}\n   */\n  tracking.ObjectTracker = function (opt_classifiers) {\n    tracking.ObjectTracker.base(this, 'constructor');\n\n    if (opt_classifiers) {\n      if (!Array.isArray(opt_classifiers)) {\n        opt_classifiers = [opt_classifiers];\n      }\n\n      if (Array.isArray(opt_classifiers)) {\n        opt_classifiers.forEach(function (classifier, i) {\n          if (typeof classifier === 'string') {\n            opt_classifiers[i] = tracking.ViolaJones.classifiers[classifier];\n          }\n\n          if (!opt_classifiers[i]) {\n            throw new Error('Object classifier not valid, try `new tracking.ObjectTracker(\"face\")`.');\n          }\n        });\n      }\n    }\n\n    this.setClassifiers(opt_classifiers);\n  };\n\n  tracking.inherits(tracking.ObjectTracker, tracking.Tracker);\n  /**\n   * Specifies the edges density of a block in order to decide whether to skip\n   * it or not.\n   * @default 0.2\n   * @type {number}\n   */\n\n  tracking.ObjectTracker.prototype.edgesDensity = 0.2;\n  /**\n   * Specifies the initial scale to start the feature block scaling.\n   * @default 1.0\n   * @type {number}\n   */\n\n  tracking.ObjectTracker.prototype.initialScale = 1.0;\n  /**\n   * Specifies the scale factor to scale the feature block.\n   * @default 1.25\n   * @type {number}\n   */\n\n  tracking.ObjectTracker.prototype.scaleFactor = 1.25;\n  /**\n   * Specifies the block step size.\n   * @default 1.5\n   * @type {number}\n   */\n\n  tracking.ObjectTracker.prototype.stepSize = 1.5;\n  /**\n   * Gets the tracker HAAR classifiers.\n   * @return {TypedArray.<number>}\n   */\n\n  tracking.ObjectTracker.prototype.getClassifiers = function () {\n    return this.classifiers;\n  };\n  /**\n   * Gets the edges density value.\n   * @return {number}\n   */\n\n\n  tracking.ObjectTracker.prototype.getEdgesDensity = function () {\n    return this.edgesDensity;\n  };\n  /**\n   * Gets the initial scale to start the feature block scaling.\n   * @return {number}\n   */\n\n\n  tracking.ObjectTracker.prototype.getInitialScale = function () {\n    return this.initialScale;\n  };\n  /**\n   * Gets the scale factor to scale the feature block.\n   * @return {number}\n   */\n\n\n  tracking.ObjectTracker.prototype.getScaleFactor = function () {\n    return this.scaleFactor;\n  };\n  /**\n   * Gets the block step size.\n   * @return {number}\n   */\n\n\n  tracking.ObjectTracker.prototype.getStepSize = function () {\n    return this.stepSize;\n  };\n  /**\n   * Tracks the `Video` frames. This method is called for each video frame in\n   * order to emit `track` event.\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\n   * @param {number} width The pixels canvas width.\n   * @param {number} height The pixels canvas height.\n   */\n\n\n  tracking.ObjectTracker.prototype.track = function (pixels, width, height) {\n    var self = this;\n    var classifiers = this.getClassifiers();\n\n    if (!classifiers) {\n      throw new Error('Object classifier not specified, try `new tracking.ObjectTracker(\"face\")`.');\n    }\n\n    var results = [];\n    classifiers.forEach(function (classifier) {\n      results = results.concat(tracking.ViolaJones.detect(pixels, width, height, self.getInitialScale(), self.getScaleFactor(), self.getStepSize(), self.getEdgesDensity(), classifier));\n    });\n    this.emit('track', {\n      data: results\n    });\n  };\n  /**\n   * Sets the tracker HAAR classifiers.\n   * @param {TypedArray.<number>} classifiers\n   */\n\n\n  tracking.ObjectTracker.prototype.setClassifiers = function (classifiers) {\n    this.classifiers = classifiers;\n  };\n  /**\n   * Sets the edges density.\n   * @param {number} edgesDensity\n   */\n\n\n  tracking.ObjectTracker.prototype.setEdgesDensity = function (edgesDensity) {\n    this.edgesDensity = edgesDensity;\n  };\n  /**\n   * Sets the initial scale to start the block scaling.\n   * @param {number} initialScale\n   */\n\n\n  tracking.ObjectTracker.prototype.setInitialScale = function (initialScale) {\n    this.initialScale = initialScale;\n  };\n  /**\n   * Sets the scale factor to scale the feature block.\n   * @param {number} scaleFactor\n   */\n\n\n  tracking.ObjectTracker.prototype.setScaleFactor = function (scaleFactor) {\n    this.scaleFactor = scaleFactor;\n  };\n  /**\n   * Sets the block step size.\n   * @param {number} stepSize\n   */\n\n\n  tracking.ObjectTracker.prototype.setStepSize = function (stepSize) {\n    this.stepSize = stepSize;\n  };\n})();","map":{"version":3,"sources":["/Users/ethan/Desktop/smileai/node_modules/tracking/build/tracking.js"],"names":["window","undefined","tracking","inherits","childCtor","parentCtor","TempCtor","prototype","superClass_","constructor","base","me","methodName","args","Array","slice","call","arguments","apply","initUserMedia_","element","opt_options","navigator","getUserMedia","video","audio","stream","src","URL","createObjectURL","err","Error","isNode","o","nodeType","isWindow","alert","document","one","selector","opt_element","querySelector","track","tracker","nodeName","toLowerCase","trackCanvas_","trackImg_","camera","trackVideo_","self","task","TrackerTask","on","trackCanvasInternal_","run","width","height","context","getContext","imageData","getImageData","data","canvas","createElement","Canvas","loadImage","resizeCanvas_","offsetWidth","offsetHeight","addEventListener","requestId","requestAnimationFrame_","requestAnimationFrame","readyState","HAVE_ENOUGH_DATA","drawImage","cancelAnimationFrame","webkitURL","msURL","oURL","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","EventEmitter","events_","addListener","event","listener","TypeError","emit","push","listeners","i","length","once","handlerInternal","removeListener","removeAllListeners","opt_event","isArray","indexOf","splice","setMaxListeners","x","y","opt_callback","instance","img","Image","crossOrigin","onload","DisjointSet","parent","Uint32Array","find","union","j","iRepresentative","jRepresentative","blur","pixels","diameter","Math","abs","radius","len","ceil","weights","Float32Array","rho","rhoSq","gaussianFactor","sqrt","PI","rhoFactor","wsum","middle","floor","gx","exp","separableConvolve","computeIntegralImage","opt_integralImage","opt_integralImageSquare","opt_tiltedIntegralImage","opt_integralImageSobel","pixelsSobel","sobel","w","pixel","computePixelValueSAT_","w1","pixelAbove","computePixelValueRSAT_","RSAT","SAT","grayscale","fillRGBA","gray","Uint8ClampedArray","p","value","horizontalConvolve","weightsVector","opaque","side","halfSide","output","alphaFac","sy","sx","offset","r","g","b","a","cx","scy","scx","min","max","poffset","wt","verticalConvolve","cy","horizWeights","vertWeights","vertical","sobelSignVector","sobelScaleVector","horizontal","v","h","ViolaJones","REGIONS_OVERLAP","classifiers","detect","initialScale","scaleFactor","stepSize","edgesDensity","total","rects","integralImage","Int32Array","integralImageSquare","tiltedIntegralImage","integralImageSobel","minWidth","minHeight","scale","blockWidth","blockHeight","step","isTriviallyExcluded","evalStages_","mergeRectangles_","wbA","wbB","wbD","wbC","blockEdgesDensity","inverseArea","mean","variance","standardDeviation","stageSum","stageThreshold","nodeLength","rectsSum","tilted","rectsLength","rectLeft","rectTop","rectWidth","rectHeight","rectWeight","w2","w3","w4","nodeThreshold","nodeLeft","nodeRight","disjointSet","r1","r2","intersectRect","x1","y1","x2","y2","overlap","area1","area2","map","k","rep","result","Object","keys","forEach","key","rect","Brief","N","randomImageOffsets_","randomWindowOffsets_","getDescriptors","keypoints","descriptors","descriptorWord","offsets","getRandomOffsets_","position","offsetsPosition","n","match","keypoints1","descriptors1","keypoints2","descriptors2","len1","len2","matches","Infinity","minj","dist","hammingWeight","index1","index2","keypoint1","keypoint2","confidence","reciprocalMatch","matches1","matches2","windowPosition","windowOffsets","round","uniformRandom","imagePosition","imageOffsets","Fast","THRESHOLD","circles_","findCorners","opt_threshold","circleOffsets","getCircleOffsets_","circlePixels","corners","isCorner","isBrighter","circlePixel","threshold","darker","brighter","isDarker","count","circleBottom","circleLeft","circleRight","circleTop","circle","distance","x0","y0","dx","dy","random","x3","y3","Matrix","fn","opt_jump","EPnP","solve","objectPoints","imagePoints","cameraMatrix","Tracker","setTracker","tracker_","running_","getTracker","inRunning","setRunning","running","reemitTrackEvent_","stop","ColorTracker","opt_colors","color","getColor","setColors","knownColors_","neighbours_","registerColor","name","colors","minDimension","maxDimension","minGroupSize","calculateDimensions_","cloud","maxx","maxy","minx","miny","c","getColors","getMinDimension","getMaxDimension","getMinGroupSize","getNeighboursForWidth_","neighbours","intersects","results","s","setMinDimension","setMaxDimension","setMinGroupSize","concat","trackColor_","colorFn","currGroup","currGroupSize","currI","currJ","currW","marked","Int8Array","neighboursW","queue","queuePosition","otherW","otherI","neighboursI","otherJ","neighboursJ","thresholdGreen","thresholdBlue","dz","ObjectTracker","opt_classifiers","classifier","setClassifiers","getClassifiers","getEdgesDensity","getInitialScale","getScaleFactor","getStepSize","setEdgesDensity","setInitialScale","setScaleFactor","setStepSize"],"mappings":"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","sourcesContent":["/**\n * tracking - A modern approach for Computer Vision on the web.\n * @author Eduardo Lundgren <edu@rdo.io>\n * @version v1.1.2\n * @link http://trackingjs.com\n * @license BSD\n */\n(function(window, undefined) {\n  window.tracking = window.tracking || {};\n\n  /**\n   * Inherit the prototype methods from one constructor into another.\n   *\n   * Usage:\n   * <pre>\n   * function ParentClass(a, b) { }\n   * ParentClass.prototype.foo = function(a) { }\n   *\n   * function ChildClass(a, b, c) {\n   *   tracking.base(this, a, b);\n   * }\n   * tracking.inherits(ChildClass, ParentClass);\n   *\n   * var child = new ChildClass('a', 'b', 'c');\n   * child.foo();\n   * </pre>\n   *\n   * @param {Function} childCtor Child class.\n   * @param {Function} parentCtor Parent class.\n   */\n  tracking.inherits = function(childCtor, parentCtor) {\n    function TempCtor() {\n    }\n    TempCtor.prototype = parentCtor.prototype;\n    childCtor.superClass_ = parentCtor.prototype;\n    childCtor.prototype = new TempCtor();\n    childCtor.prototype.constructor = childCtor;\n\n    /**\n     * Calls superclass constructor/method.\n     *\n     * This function is only available if you use tracking.inherits to express\n     * inheritance relationships between classes.\n     *\n     * @param {!object} me Should always be \"this\".\n     * @param {string} methodName The method name to call. Calling superclass\n     *     constructor can be done with the special string 'constructor'.\n     * @param {...*} var_args The arguments to pass to superclass\n     *     method/constructor.\n     * @return {*} The return value of the superclass method/constructor.\n     */\n    childCtor.base = function(me, methodName) {\n      var args = Array.prototype.slice.call(arguments, 2);\n      return parentCtor.prototype[methodName].apply(me, args);\n    };\n  };\n\n  /**\n   * Captures the user camera when tracking a video element and set its source\n   * to the camera stream.\n   * @param {HTMLVideoElement} element Canvas element to track.\n   * @param {object} opt_options Optional configuration to the tracker.\n   */\n  tracking.initUserMedia_ = function(element, opt_options) {\n    window.navigator.getUserMedia({\n      video: true,\n      audio: !!(opt_options && opt_options.audio)\n    }, function(stream) {\n        try {\n          element.src = window.URL.createObjectURL(stream);\n        } catch (err) {\n          element.src = stream;\n        }\n      }, function() {\n        throw Error('Cannot capture user camera.');\n      }\n    );\n  };\n\n  /**\n   * Tests whether the object is a dom node.\n   * @param {object} o Object to be tested.\n   * @return {boolean} True if the object is a dom node.\n   */\n  tracking.isNode = function(o) {\n    return o.nodeType || this.isWindow(o);\n  };\n\n  /**\n   * Tests whether the object is the `window` object.\n   * @param {object} o Object to be tested.\n   * @return {boolean} True if the object is the `window` object.\n   */\n  tracking.isWindow = function(o) {\n    return !!(o && o.alert && o.document);\n  };\n\n  /**\n   * Selects a dom node from a CSS3 selector using `document.querySelector`.\n   * @param {string} selector\n   * @param {object} opt_element The root element for the query. When not\n   *     specified `document` is used as root element.\n   * @return {HTMLElement} The first dom element that matches to the selector.\n   *     If not found, returns `null`.\n   */\n  tracking.one = function(selector, opt_element) {\n    if (this.isNode(selector)) {\n      return selector;\n    }\n    return (opt_element || document).querySelector(selector);\n  };\n\n  /**\n   * Tracks a canvas, image or video element based on the specified `tracker`\n   * instance. This method extract the pixel information of the input element\n   * to pass to the `tracker` instance. When tracking a video, the\n   * `tracker.track(pixels, width, height)` will be in a\n   * `requestAnimationFrame` loop in order to track all video frames.\n   *\n   * Example:\n   * var tracker = new tracking.ColorTracker();\n   *\n   * tracking.track('#video', tracker);\n   * or\n   * tracking.track('#video', tracker, { camera: true });\n   *\n   * tracker.on('track', function(event) {\n   *   // console.log(event.data[0].x, event.data[0].y)\n   * });\n   *\n   * @param {HTMLElement} element The element to track, canvas, image or\n   *     video.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   */\n  tracking.track = function(element, tracker, opt_options) {\n    element = tracking.one(element);\n    if (!element) {\n      throw new Error('Element not found, try a different element or selector.');\n    }\n    if (!tracker) {\n      throw new Error('Tracker not specified, try `tracking.track(element, new tracking.FaceTracker())`.');\n    }\n\n    switch (element.nodeName.toLowerCase()) {\n      case 'canvas':\n        return this.trackCanvas_(element, tracker, opt_options);\n      case 'img':\n        return this.trackImg_(element, tracker, opt_options);\n      case 'video':\n        if (opt_options) {\n          if (opt_options.camera) {\n            this.initUserMedia_(element, opt_options);\n          }\n        }\n        return this.trackVideo_(element, tracker, opt_options);\n      default:\n        throw new Error('Element not supported, try in a canvas, img, or video.');\n    }\n  };\n\n  /**\n   * Tracks a canvas element based on the specified `tracker` instance and\n   * returns a `TrackerTask` for this track.\n   * @param {HTMLCanvasElement} element Canvas element to track.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   * @return {tracking.TrackerTask}\n   * @private\n   */\n  tracking.trackCanvas_ = function(element, tracker) {\n    var self = this;\n    var task = new tracking.TrackerTask(tracker);\n    task.on('run', function() {\n      self.trackCanvasInternal_(element, tracker);\n    });\n    return task.run();\n  };\n\n  /**\n   * Tracks a canvas element based on the specified `tracker` instance. This\n   * method extract the pixel information of the input element to pass to the\n   * `tracker` instance.\n   * @param {HTMLCanvasElement} element Canvas element to track.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   * @private\n   */\n  tracking.trackCanvasInternal_ = function(element, tracker) {\n    var width = element.width;\n    var height = element.height;\n    var context = element.getContext('2d');\n    var imageData = context.getImageData(0, 0, width, height);\n    tracker.track(imageData.data, width, height);\n  };\n\n  /**\n   * Tracks a image element based on the specified `tracker` instance. This\n   * method extract the pixel information of the input element to pass to the\n   * `tracker` instance.\n   * @param {HTMLImageElement} element Canvas element to track.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   * @private\n   */\n  tracking.trackImg_ = function(element, tracker) {\n    var width = element.width;\n    var height = element.height;\n    var canvas = document.createElement('canvas');\n\n    canvas.width = width;\n    canvas.height = height;\n\n    var task = new tracking.TrackerTask(tracker);\n    task.on('run', function() {\n      tracking.Canvas.loadImage(canvas, element.src, 0, 0, width, height, function() {\n        tracking.trackCanvasInternal_(canvas, tracker);\n      });\n    });\n    return task.run();\n  };\n\n  /**\n   * Tracks a video element based on the specified `tracker` instance. This\n   * method extract the pixel information of the input element to pass to the\n   * `tracker` instance. The `tracker.track(pixels, width, height)` will be in\n   * a `requestAnimationFrame` loop in order to track all video frames.\n   * @param {HTMLVideoElement} element Canvas element to track.\n   * @param {tracking.Tracker} tracker The tracker instance used to track the\n   *     element.\n   * @param {object} opt_options Optional configuration to the tracker.\n   * @private\n   */\n  tracking.trackVideo_ = function(element, tracker) {\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    var width;\n    var height;\n\n    var resizeCanvas_ = function() {\n      width = element.offsetWidth;\n      height = element.offsetHeight;\n      canvas.width = width;\n      canvas.height = height;\n    };\n    resizeCanvas_();\n    element.addEventListener('resize', resizeCanvas_);\n\n    var requestId;\n    var requestAnimationFrame_ = function() {\n      requestId = window.requestAnimationFrame(function() {\n        if (element.readyState === element.HAVE_ENOUGH_DATA) {\n          try {\n            // Firefox v~30.0 gets confused with the video readyState firing an\n            // erroneous HAVE_ENOUGH_DATA just before HAVE_CURRENT_DATA state,\n            // hence keep trying to read it until resolved.\n            context.drawImage(element, 0, 0, width, height);\n          } catch (err) {}\n          tracking.trackCanvasInternal_(canvas, tracker);\n        }\n        requestAnimationFrame_();\n      });\n    };\n\n    var task = new tracking.TrackerTask(tracker);\n    task.on('stop', function() {\n      window.cancelAnimationFrame(requestId);\n    });\n    task.on('run', function() {\n      requestAnimationFrame_();\n    });\n    return task.run();\n  };\n\n  // Browser polyfills\n  //===================\n\n  if (!window.URL) {\n    window.URL = window.URL || window.webkitURL || window.msURL || window.oURL;\n  }\n\n  if (!navigator.getUserMedia) {\n    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia || navigator.msGetUserMedia;\n  }\n}(window));\n\n(function() {\n  /**\n   * EventEmitter utility.\n   * @constructor\n   */\n  tracking.EventEmitter = function() {};\n\n  /**\n   * Holds event listeners scoped by event type.\n   * @type {object}\n   * @private\n   */\n  tracking.EventEmitter.prototype.events_ = null;\n\n  /**\n   * Adds a listener to the end of the listeners array for the specified event.\n   * @param {string} event\n   * @param {function} listener\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n  tracking.EventEmitter.prototype.addListener = function(event, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('Listener must be a function');\n    }\n    if (!this.events_) {\n      this.events_ = {};\n    }\n\n    this.emit('newListener', event, listener);\n\n    if (!this.events_[event]) {\n      this.events_[event] = [];\n    }\n\n    this.events_[event].push(listener);\n\n    return this;\n  };\n\n  /**\n   * Returns an array of listeners for the specified event.\n   * @param {string} event\n   * @return {array} Array of listeners.\n   */\n  tracking.EventEmitter.prototype.listeners = function(event) {\n    return this.events_ && this.events_[event];\n  };\n\n  /**\n   * Execute each of the listeners in order with the supplied arguments.\n   * @param {string} event\n   * @param {*} opt_args [arg1], [arg2], [...]\n   * @return {boolean} Returns true if event had listeners, false otherwise.\n   */\n  tracking.EventEmitter.prototype.emit = function(event) {\n    var listeners = this.listeners(event);\n    if (listeners) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]) {\n          listeners[i].apply(this, args);\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Adds a listener to the end of the listeners array for the specified event.\n   * @param {string} event\n   * @param {function} listener\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n  tracking.EventEmitter.prototype.on = tracking.EventEmitter.prototype.addListener;\n\n  /**\n   * Adds a one time listener for the event. This listener is invoked only the\n   * next time the event is fired, after which it is removed.\n   * @param {string} event\n   * @param {function} listener\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n  tracking.EventEmitter.prototype.once = function(event, listener) {\n    var self = this;\n    self.on(event, function handlerInternal() {\n      self.removeListener(event, handlerInternal);\n      listener.apply(this, arguments);\n    });\n  };\n\n  /**\n   * Removes all listeners, or those of the specified event. It's not a good\n   * idea to remove listeners that were added elsewhere in the code,\n   * especially when it's on an emitter that you didn't create.\n   * @param {string} event\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n  tracking.EventEmitter.prototype.removeAllListeners = function(opt_event) {\n    if (!this.events_) {\n      return this;\n    }\n    if (opt_event) {\n      delete this.events_[opt_event];\n    } else {\n      delete this.events_;\n    }\n    return this;\n  };\n\n  /**\n   * Remove a listener from the listener array for the specified event.\n   * Caution: changes array indices in the listener array behind the listener.\n   * @param {string} event\n   * @param {function} listener\n   * @return {object} Returns emitter, so calls can be chained.\n   */\n  tracking.EventEmitter.prototype.removeListener = function(event, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('Listener must be a function');\n    }\n    if (!this.events_) {\n      return this;\n    }\n\n    var listeners = this.listeners(event);\n    if (Array.isArray(listeners)) {\n      var i = listeners.indexOf(listener);\n      if (i < 0) {\n        return this;\n      }\n      listeners.splice(i, 1);\n    }\n\n    return this;\n  };\n\n  /**\n   * By default EventEmitters will print a warning if more than 10 listeners\n   * are added for a particular event. This is a useful default which helps\n   * finding memory leaks. Obviously not all Emitters should be limited to 10.\n   * This function allows that to be increased. Set to zero for unlimited.\n   * @param {number} n The maximum number of listeners.\n   */\n  tracking.EventEmitter.prototype.setMaxListeners = function() {\n    throw new Error('Not implemented');\n  };\n\n}());\n\n(function() {\n  /**\n   * Canvas utility.\n   * @static\n   * @constructor\n   */\n  tracking.Canvas = {};\n\n  /**\n   * Loads an image source into the canvas.\n   * @param {HTMLCanvasElement} canvas The canvas dom element.\n   * @param {string} src The image source.\n   * @param {number} x The canvas horizontal coordinate to load the image.\n   * @param {number} y The canvas vertical coordinate to load the image.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {function} opt_callback Callback that fires when the image is loaded\n   *     into the canvas.\n   * @static\n   */\n  tracking.Canvas.loadImage = function(canvas, src, x, y, width, height, opt_callback) {\n    var instance = this;\n    var img = new window.Image();\n    img.crossOrigin = '*';\n    img.onload = function() {\n      var context = canvas.getContext('2d');\n      canvas.width = width;\n      canvas.height = height;\n      context.drawImage(img, x, y, width, height);\n      if (opt_callback) {\n        opt_callback.call(instance);\n      }\n      img = null;\n    };\n    img.src = src;\n  };\n}());\n\n(function() {\n  /**\n   * DisjointSet utility with path compression. Some applications involve\n   * grouping n distinct objects into a collection of disjoint sets. Two\n   * important operations are then finding which set a given object belongs to\n   * and uniting the two sets. A disjoint set data structure maintains a\n   * collection S={ S1 , S2 ,..., Sk } of disjoint dynamic sets. Each set is\n   * identified by a representative, which usually is a member in the set.\n   * @static\n   * @constructor\n   */\n  tracking.DisjointSet = function(length) {\n    if (length === undefined) {\n      throw new Error('DisjointSet length not specified.');\n    }\n    this.length = length;\n    this.parent = new Uint32Array(length);\n    for (var i = 0; i < length; i++) {\n      this.parent[i] = i;\n    }\n  };\n\n  /**\n   * Holds the length of the internal set.\n   * @type {number}\n   */\n  tracking.DisjointSet.prototype.length = null;\n\n  /**\n   * Holds the set containing the representative values.\n   * @type {Array.<number>}\n   */\n  tracking.DisjointSet.prototype.parent = null;\n\n  /**\n   * Finds a pointer to the representative of the set containing i.\n   * @param {number} i\n   * @return {number} The representative set of i.\n   */\n  tracking.DisjointSet.prototype.find = function(i) {\n    if (this.parent[i] === i) {\n      return i;\n    } else {\n      return (this.parent[i] = this.find(this.parent[i]));\n    }\n  };\n\n  /**\n   * Unites two dynamic sets containing objects i and j, say Si and Sj, into\n   * a new set that Si ∪ Sj, assuming that Si ∩ Sj = ∅;\n   * @param {number} i\n   * @param {number} j\n   */\n  tracking.DisjointSet.prototype.union = function(i, j) {\n    var iRepresentative = this.find(i);\n    var jRepresentative = this.find(j);\n    this.parent[iRepresentative] = jRepresentative;\n  };\n\n}());\n\n(function() {\n  /**\n   * Image utility.\n   * @static\n   * @constructor\n   */\n  tracking.Image = {};\n\n  /**\n   * Computes gaussian blur. Adapted from\n   * https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {number} diameter Gaussian blur diameter, must be greater than 1.\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\n   */\n  tracking.Image.blur = function(pixels, width, height, diameter) {\n    diameter = Math.abs(diameter);\n    if (diameter <= 1) {\n      throw new Error('Diameter should be greater than 1.');\n    }\n    var radius = diameter / 2;\n    var len = Math.ceil(diameter) + (1 - (Math.ceil(diameter) % 2));\n    var weights = new Float32Array(len);\n    var rho = (radius + 0.5) / 3;\n    var rhoSq = rho * rho;\n    var gaussianFactor = 1 / Math.sqrt(2 * Math.PI * rhoSq);\n    var rhoFactor = -1 / (2 * rho * rho);\n    var wsum = 0;\n    var middle = Math.floor(len / 2);\n    for (var i = 0; i < len; i++) {\n      var x = i - middle;\n      var gx = gaussianFactor * Math.exp(x * x * rhoFactor);\n      weights[i] = gx;\n      wsum += gx;\n    }\n    for (var j = 0; j < weights.length; j++) {\n      weights[j] /= wsum;\n    }\n    return this.separableConvolve(pixels, width, height, weights, weights, false);\n  };\n\n  /**\n   * Computes the integral image for summed, squared, rotated and sobel pixels.\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\n   *     through.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {array} opt_integralImage Empty array of size `width * height` to\n   *     be filled with the integral image values. If not specified compute sum\n   *     values will be skipped.\n   * @param {array} opt_integralImageSquare Empty array of size `width *\n   *     height` to be filled with the integral image squared values. If not\n   *     specified compute squared values will be skipped.\n   * @param {array} opt_tiltedIntegralImage Empty array of size `width *\n   *     height` to be filled with the rotated integral image values. If not\n   *     specified compute sum values will be skipped.\n   * @param {array} opt_integralImageSobel Empty array of size `width *\n   *     height` to be filled with the integral image of sobel values. If not\n   *     specified compute sobel filtering will be skipped.\n   * @static\n   */\n  tracking.Image.computeIntegralImage = function(pixels, width, height, opt_integralImage, opt_integralImageSquare, opt_tiltedIntegralImage, opt_integralImageSobel) {\n    if (arguments.length < 4) {\n      throw new Error('You should specify at least one output array in the order: sum, square, tilted, sobel.');\n    }\n    var pixelsSobel;\n    if (opt_integralImageSobel) {\n      pixelsSobel = tracking.Image.sobel(pixels, width, height);\n    }\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        var w = i * width * 4 + j * 4;\n        var pixel = ~~(pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114);\n        if (opt_integralImage) {\n          this.computePixelValueSAT_(opt_integralImage, width, i, j, pixel);\n        }\n        if (opt_integralImageSquare) {\n          this.computePixelValueSAT_(opt_integralImageSquare, width, i, j, pixel * pixel);\n        }\n        if (opt_tiltedIntegralImage) {\n          var w1 = w - width * 4;\n          var pixelAbove = ~~(pixels[w1] * 0.299 + pixels[w1 + 1] * 0.587 + pixels[w1 + 2] * 0.114);\n          this.computePixelValueRSAT_(opt_tiltedIntegralImage, width, i, j, pixel, pixelAbove || 0);\n        }\n        if (opt_integralImageSobel) {\n          this.computePixelValueSAT_(opt_integralImageSobel, width, i, j, pixelsSobel[w]);\n        }\n      }\n    }\n  };\n\n  /**\n   * Helper method to compute the rotated summed area table (RSAT) by the\n   * formula:\n   *\n   * RSAT(x, y) = RSAT(x-1, y-1) + RSAT(x+1, y-1) - RSAT(x, y-2) + I(x, y) + I(x, y-1)\n   *\n   * @param {number} width The image width.\n   * @param {array} RSAT Empty array of size `width * height` to be filled with\n   *     the integral image values. If not specified compute sum values will be\n   *     skipped.\n   * @param {number} i Vertical position of the pixel to be evaluated.\n   * @param {number} j Horizontal position of the pixel to be evaluated.\n   * @param {number} pixel Pixel value to be added to the integral image.\n   * @static\n   * @private\n   */\n  tracking.Image.computePixelValueRSAT_ = function(RSAT, width, i, j, pixel, pixelAbove) {\n    var w = i * width + j;\n    RSAT[w] = (RSAT[w - width - 1] || 0) + (RSAT[w - width + 1] || 0) - (RSAT[w - width - width] || 0) + pixel + pixelAbove;\n  };\n\n  /**\n   * Helper method to compute the summed area table (SAT) by the formula:\n   *\n   * SAT(x, y) = SAT(x, y-1) + SAT(x-1, y) + I(x, y) - SAT(x-1, y-1)\n   *\n   * @param {number} width The image width.\n   * @param {array} SAT Empty array of size `width * height` to be filled with\n   *     the integral image values. If not specified compute sum values will be\n   *     skipped.\n   * @param {number} i Vertical position of the pixel to be evaluated.\n   * @param {number} j Horizontal position of the pixel to be evaluated.\n   * @param {number} pixel Pixel value to be added to the integral image.\n   * @static\n   * @private\n   */\n  tracking.Image.computePixelValueSAT_ = function(SAT, width, i, j, pixel) {\n    var w = i * width + j;\n    SAT[w] = (SAT[w - width] || 0) + (SAT[w - 1] || 0) + pixel - (SAT[w - width - 1] || 0);\n  };\n\n  /**\n   * Converts a color from a colorspace based on an RGB color model to a\n   * grayscale representation of its luminance. The coefficients represent the\n   * measured intensity perception of typical trichromat humans, in\n   * particular, human vision is most sensitive to green and least sensitive\n   * to blue.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {boolean} fillRGBA If the result should fill all RGBA values with the gray scale\n   *  values, instead of returning a single value per pixel.\n   * @param {Uint8ClampedArray} The grayscale pixels in a linear array ([p,p,p,a,...] if fillRGBA\n   *  is true and [p1, p2, p3, ...] if fillRGBA is false).\n   * @static\n   */\n  tracking.Image.grayscale = function(pixels, width, height, fillRGBA) {\n    var gray = new Uint8ClampedArray(fillRGBA ? pixels.length : pixels.length >> 2);\n    var p = 0;\n    var w = 0;\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        var value = pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114;\n        gray[p++] = value;\n\n        if (fillRGBA) {\n          gray[p++] = value;\n          gray[p++] = value;\n          gray[p++] = pixels[w + 3];\n        }\n\n        w += 4;\n      }\n    }\n    return gray;\n  };\n\n  /**\n   * Fast horizontal separable convolution. A point spread function (PSF) is\n   * said to be separable if it can be broken into two one-dimensional\n   * signals: a vertical and a horizontal projection. The convolution is\n   * performed by sliding the kernel over the image, generally starting at the\n   * top left corner, so as to move the kernel through all the positions where\n   * the kernel fits entirely within the boundaries of the image. Adapted from\n   * https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\n   * @param {number} opaque\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\n   */\n  tracking.Image.horizontalConvolve = function(pixels, width, height, weightsVector, opaque) {\n    var side = weightsVector.length;\n    var halfSide = Math.floor(side / 2);\n    var output = new Float32Array(width * height * 4);\n    var alphaFac = opaque ? 1 : 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var sy = y;\n        var sx = x;\n        var offset = (y * width + x) * 4;\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        var a = 0;\n        for (var cx = 0; cx < side; cx++) {\n          var scy = sy;\n          var scx = Math.min(width - 1, Math.max(0, sx + cx - halfSide));\n          var poffset = (scy * width + scx) * 4;\n          var wt = weightsVector[cx];\n          r += pixels[poffset] * wt;\n          g += pixels[poffset + 1] * wt;\n          b += pixels[poffset + 2] * wt;\n          a += pixels[poffset + 3] * wt;\n        }\n        output[offset] = r;\n        output[offset + 1] = g;\n        output[offset + 2] = b;\n        output[offset + 3] = a + alphaFac * (255 - a);\n      }\n    }\n    return output;\n  };\n\n  /**\n   * Fast vertical separable convolution. A point spread function (PSF) is\n   * said to be separable if it can be broken into two one-dimensional\n   * signals: a vertical and a horizontal projection. The convolution is\n   * performed by sliding the kernel over the image, generally starting at the\n   * top left corner, so as to move the kernel through all the positions where\n   * the kernel fits entirely within the boundaries of the image. Adapted from\n   * https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\n   * @param {number} opaque\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\n   */\n  tracking.Image.verticalConvolve = function(pixels, width, height, weightsVector, opaque) {\n    var side = weightsVector.length;\n    var halfSide = Math.floor(side / 2);\n    var output = new Float32Array(width * height * 4);\n    var alphaFac = opaque ? 1 : 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var sy = y;\n        var sx = x;\n        var offset = (y * width + x) * 4;\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        var a = 0;\n        for (var cy = 0; cy < side; cy++) {\n          var scy = Math.min(height - 1, Math.max(0, sy + cy - halfSide));\n          var scx = sx;\n          var poffset = (scy * width + scx) * 4;\n          var wt = weightsVector[cy];\n          r += pixels[poffset] * wt;\n          g += pixels[poffset + 1] * wt;\n          b += pixels[poffset + 2] * wt;\n          a += pixels[poffset + 3] * wt;\n        }\n        output[offset] = r;\n        output[offset + 1] = g;\n        output[offset + 2] = b;\n        output[offset + 3] = a + alphaFac * (255 - a);\n      }\n    }\n    return output;\n  };\n\n  /**\n   * Fast separable convolution. A point spread function (PSF) is said to be\n   * separable if it can be broken into two one-dimensional signals: a\n   * vertical and a horizontal projection. The convolution is performed by\n   * sliding the kernel over the image, generally starting at the top left\n   * corner, so as to move the kernel through all the positions where the\n   * kernel fits entirely within the boundaries of the image. Adapted from\n   * https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {array} horizWeights The horizontal weighting vector, e.g [-1,0,1].\n   * @param {array} vertWeights The vertical vector, e.g [-1,0,1].\n   * @param {number} opaque\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\n   */\n  tracking.Image.separableConvolve = function(pixels, width, height, horizWeights, vertWeights, opaque) {\n    var vertical = this.verticalConvolve(pixels, width, height, vertWeights, opaque);\n    return this.horizontalConvolve(vertical, width, height, horizWeights, opaque);\n  };\n\n  /**\n   * Compute image edges using Sobel operator. Computes the vertical and\n   * horizontal gradients of the image and combines the computed images to\n   * find edges in the image. The way we implement the Sobel filter here is by\n   * first grayscaling the image, then taking the horizontal and vertical\n   * gradients and finally combining the gradient images to make up the final\n   * image. Adapted from https://github.com/kig/canvasfilters.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\n   */\n  tracking.Image.sobel = function(pixels, width, height) {\n    pixels = this.grayscale(pixels, width, height, true);\n    var output = new Float32Array(width * height * 4);\n    var sobelSignVector = new Float32Array([-1, 0, 1]);\n    var sobelScaleVector = new Float32Array([1, 2, 1]);\n    var vertical = this.separableConvolve(pixels, width, height, sobelSignVector, sobelScaleVector);\n    var horizontal = this.separableConvolve(pixels, width, height, sobelScaleVector, sobelSignVector);\n\n    for (var i = 0; i < output.length; i += 4) {\n      var v = vertical[i];\n      var h = horizontal[i];\n      var p = Math.sqrt(h * h + v * v);\n      output[i] = p;\n      output[i + 1] = p;\n      output[i + 2] = p;\n      output[i + 3] = 255;\n    }\n\n    return output;\n  };\n\n}());\n\n(function() {\n  /**\n   * ViolaJones utility.\n   * @static\n   * @constructor\n   */\n  tracking.ViolaJones = {};\n\n  /**\n   * Holds the minimum area of intersection that defines when a rectangle is\n   * from the same group. Often when a face is matched multiple rectangles are\n   * classified as possible rectangles to represent the face, when they\n   * intersects they are grouped as one face.\n   * @type {number}\n   * @default 0.5\n   * @static\n   */\n  tracking.ViolaJones.REGIONS_OVERLAP = 0.5;\n\n  /**\n   * Holds the HAAR cascade classifiers converted from OpenCV training.\n   * @type {array}\n   * @static\n   */\n  tracking.ViolaJones.classifiers = {};\n\n  /**\n   * Detects through the HAAR cascade data rectangles matches.\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {number} initialScale The initial scale to start the block\n   *     scaling.\n   * @param {number} scaleFactor The scale factor to scale the feature block.\n   * @param {number} stepSize The block step size.\n   * @param {number} edgesDensity Percentage density edges inside the\n   *     classifier block. Value from [0.0, 1.0], defaults to 0.2. If specified\n   *     edge detection will be applied to the image to prune dead areas of the\n   *     image, this can improve significantly performance.\n   * @param {number} data The HAAR cascade data.\n   * @return {array} Found rectangles.\n   * @static\n   */\n  tracking.ViolaJones.detect = function(pixels, width, height, initialScale, scaleFactor, stepSize, edgesDensity, data) {\n    var total = 0;\n    var rects = [];\n    var integralImage = new Int32Array(width * height);\n    var integralImageSquare = new Int32Array(width * height);\n    var tiltedIntegralImage = new Int32Array(width * height);\n\n    var integralImageSobel;\n    if (edgesDensity > 0) {\n      integralImageSobel = new Int32Array(width * height);\n    }\n\n    tracking.Image.computeIntegralImage(pixels, width, height, integralImage, integralImageSquare, tiltedIntegralImage, integralImageSobel);\n\n    var minWidth = data[0];\n    var minHeight = data[1];\n    var scale = initialScale * scaleFactor;\n    var blockWidth = (scale * minWidth) | 0;\n    var blockHeight = (scale * minHeight) | 0;\n\n    while (blockWidth < width && blockHeight < height) {\n      var step = (scale * stepSize + 0.5) | 0;\n      for (var i = 0; i < (height - blockHeight); i += step) {\n        for (var j = 0; j < (width - blockWidth); j += step) {\n\n          if (edgesDensity > 0) {\n            if (this.isTriviallyExcluded(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight)) {\n              continue;\n            }\n          }\n\n          if (this.evalStages_(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale)) {\n            rects[total++] = {\n              width: blockWidth,\n              height: blockHeight,\n              x: j,\n              y: i\n            };\n          }\n        }\n      }\n\n      scale *= scaleFactor;\n      blockWidth = (scale * minWidth) | 0;\n      blockHeight = (scale * minHeight) | 0;\n    }\n    return this.mergeRectangles_(rects);\n  };\n\n  /**\n   * Fast check to test whether the edges density inside the block is greater\n   * than a threshold, if true it tests the stages. This can improve\n   * significantly performance.\n   * @param {number} edgesDensity Percentage density edges inside the\n   *     classifier block.\n   * @param {array} integralImageSobel The integral image of a sobel image.\n   * @param {number} i Vertical position of the pixel to be evaluated.\n   * @param {number} j Horizontal position of the pixel to be evaluated.\n   * @param {number} width The image width.\n   * @return {boolean} True whether the block at position i,j can be skipped,\n   *     false otherwise.\n   * @static\n   * @protected\n   */\n  tracking.ViolaJones.isTriviallyExcluded = function(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight) {\n    var wbA = i * width + j;\n    var wbB = wbA + blockWidth;\n    var wbD = wbA + blockHeight * width;\n    var wbC = wbD + blockWidth;\n    var blockEdgesDensity = (integralImageSobel[wbA] - integralImageSobel[wbB] - integralImageSobel[wbD] + integralImageSobel[wbC]) / (blockWidth * blockHeight * 255);\n    if (blockEdgesDensity < edgesDensity) {\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Evaluates if the block size on i,j position is a valid HAAR cascade\n   * stage.\n   * @param {number} data The HAAR cascade data.\n   * @param {number} i Vertical position of the pixel to be evaluated.\n   * @param {number} j Horizontal position of the pixel to be evaluated.\n   * @param {number} width The image width.\n   * @param {number} blockSize The block size.\n   * @param {number} scale The scale factor of the block size and its original\n   *     size.\n   * @param {number} inverseArea The inverse area of the block size.\n   * @return {boolean} Whether the region passes all the stage tests.\n   * @private\n   * @static\n   */\n  tracking.ViolaJones.evalStages_ = function(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale) {\n    var inverseArea = 1.0 / (blockWidth * blockHeight);\n    var wbA = i * width + j;\n    var wbB = wbA + blockWidth;\n    var wbD = wbA + blockHeight * width;\n    var wbC = wbD + blockWidth;\n    var mean = (integralImage[wbA] - integralImage[wbB] - integralImage[wbD] + integralImage[wbC]) * inverseArea;\n    var variance = (integralImageSquare[wbA] - integralImageSquare[wbB] - integralImageSquare[wbD] + integralImageSquare[wbC]) * inverseArea - mean * mean;\n\n    var standardDeviation = 1;\n    if (variance > 0) {\n      standardDeviation = Math.sqrt(variance);\n    }\n\n    var length = data.length;\n\n    for (var w = 2; w < length; ) {\n      var stageSum = 0;\n      var stageThreshold = data[w++];\n      var nodeLength = data[w++];\n\n      while (nodeLength--) {\n        var rectsSum = 0;\n        var tilted = data[w++];\n        var rectsLength = data[w++];\n\n        for (var r = 0; r < rectsLength; r++) {\n          var rectLeft = (j + data[w++] * scale + 0.5) | 0;\n          var rectTop = (i + data[w++] * scale + 0.5) | 0;\n          var rectWidth = (data[w++] * scale + 0.5) | 0;\n          var rectHeight = (data[w++] * scale + 0.5) | 0;\n          var rectWeight = data[w++];\n\n          var w1;\n          var w2;\n          var w3;\n          var w4;\n          if (tilted) {\n            // RectSum(r) = RSAT(x-h+w, y+w+h-1) + RSAT(x, y-1) - RSAT(x-h, y+h-1) - RSAT(x+w, y+w-1)\n            w1 = (rectLeft - rectHeight + rectWidth) + (rectTop + rectWidth + rectHeight - 1) * width;\n            w2 = rectLeft + (rectTop - 1) * width;\n            w3 = (rectLeft - rectHeight) + (rectTop + rectHeight - 1) * width;\n            w4 = (rectLeft + rectWidth) + (rectTop + rectWidth - 1) * width;\n            rectsSum += (tiltedIntegralImage[w1] + tiltedIntegralImage[w2] - tiltedIntegralImage[w3] - tiltedIntegralImage[w4]) * rectWeight;\n          } else {\n            // RectSum(r) = SAT(x-1, y-1) + SAT(x+w-1, y+h-1) - SAT(x-1, y+h-1) - SAT(x+w-1, y-1)\n            w1 = rectTop * width + rectLeft;\n            w2 = w1 + rectWidth;\n            w3 = w1 + rectHeight * width;\n            w4 = w3 + rectWidth;\n            rectsSum += (integralImage[w1] - integralImage[w2] - integralImage[w3] + integralImage[w4]) * rectWeight;\n            // TODO: Review the code below to analyze performance when using it instead.\n            // w1 = (rectLeft - 1) + (rectTop - 1) * width;\n            // w2 = (rectLeft + rectWidth - 1) + (rectTop + rectHeight - 1) * width;\n            // w3 = (rectLeft - 1) + (rectTop + rectHeight - 1) * width;\n            // w4 = (rectLeft + rectWidth - 1) + (rectTop - 1) * width;\n            // rectsSum += (integralImage[w1] + integralImage[w2] - integralImage[w3] - integralImage[w4]) * rectWeight;\n          }\n        }\n\n        var nodeThreshold = data[w++];\n        var nodeLeft = data[w++];\n        var nodeRight = data[w++];\n\n        if (rectsSum * inverseArea < nodeThreshold * standardDeviation) {\n          stageSum += nodeLeft;\n        } else {\n          stageSum += nodeRight;\n        }\n      }\n\n      if (stageSum < stageThreshold) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Postprocess the detected sub-windows in order to combine overlapping\n   * detections into a single detection.\n   * @param {array} rects\n   * @return {array}\n   * @private\n   * @static\n   */\n  tracking.ViolaJones.mergeRectangles_ = function(rects) {\n    var disjointSet = new tracking.DisjointSet(rects.length);\n\n    for (var i = 0; i < rects.length; i++) {\n      var r1 = rects[i];\n      for (var j = 0; j < rects.length; j++) {\n        var r2 = rects[j];\n        if (tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\n          var x1 = Math.max(r1.x, r2.x);\n          var y1 = Math.max(r1.y, r2.y);\n          var x2 = Math.min(r1.x + r1.width, r2.x + r2.width);\n          var y2 = Math.min(r1.y + r1.height, r2.y + r2.height);\n          var overlap = (x1 - x2) * (y1 - y2);\n          var area1 = (r1.width * r1.height);\n          var area2 = (r2.width * r2.height);\n\n          if ((overlap / (area1 * (area1 / area2)) >= this.REGIONS_OVERLAP) &&\n            (overlap / (area2 * (area1 / area2)) >= this.REGIONS_OVERLAP)) {\n            disjointSet.union(i, j);\n          }\n        }\n      }\n    }\n\n    var map = {};\n    for (var k = 0; k < disjointSet.length; k++) {\n      var rep = disjointSet.find(k);\n      if (!map[rep]) {\n        map[rep] = {\n          total: 1,\n          width: rects[k].width,\n          height: rects[k].height,\n          x: rects[k].x,\n          y: rects[k].y\n        };\n        continue;\n      }\n      map[rep].total++;\n      map[rep].width += rects[k].width;\n      map[rep].height += rects[k].height;\n      map[rep].x += rects[k].x;\n      map[rep].y += rects[k].y;\n    }\n\n    var result = [];\n    Object.keys(map).forEach(function(key) {\n      var rect = map[key];\n      result.push({\n        total: rect.total,\n        width: (rect.width / rect.total + 0.5) | 0,\n        height: (rect.height / rect.total + 0.5) | 0,\n        x: (rect.x / rect.total + 0.5) | 0,\n        y: (rect.y / rect.total + 0.5) | 0\n      });\n    });\n\n    return result;\n  };\n\n}());\n\n(function() {\n  /**\n   * Brief intends for \"Binary Robust Independent Elementary Features\".This\n   * method generates a binary string for each keypoint found by an extractor\n   * method.\n   * @static\n   * @constructor\n   */\n  tracking.Brief = {};\n\n  /**\n   * The set of binary tests is defined by the nd (x,y)-location pairs\n   * uniquely chosen during the initialization. Values could vary between N =\n   * 128,256,512. N=128 yield good compromises between speed, storage\n   * efficiency, and recognition rate.\n   * @type {number}\n   */\n  tracking.Brief.N = 512;\n\n  /**\n   * Caches coordinates values of (x,y)-location pairs uniquely chosen during\n   * the initialization.\n   * @type {Object.<number, Int32Array>}\n   * @private\n   * @static\n   */\n  tracking.Brief.randomImageOffsets_ = {};\n\n  /**\n   * Caches delta values of (x,y)-location pairs uniquely chosen during\n   * the initialization.\n   * @type {Int32Array}\n   * @private\n   * @static\n   */\n  tracking.Brief.randomWindowOffsets_ = null;\n\n  /**\n   * Generates a binary string for each found keypoints extracted using an\n   * extractor method.\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\n   * @param {number} width The image width.\n   * @param {array} keypoints\n   * @return {Int32Array} Returns an array where for each four sequence int\n   *     values represent the descriptor binary string (128 bits) necessary\n   *     to describe the corner, e.g. [0,0,0,0, 0,0,0,0, ...].\n   * @static\n   */\n  tracking.Brief.getDescriptors = function(pixels, width, keypoints) {\n    // Optimizing divide by 32 operation using binary shift\n    // (this.N >> 5) === this.N/32.\n    var descriptors = new Int32Array((keypoints.length >> 1) * (this.N >> 5));\n    var descriptorWord = 0;\n    var offsets = this.getRandomOffsets_(width);\n    var position = 0;\n\n    for (var i = 0; i < keypoints.length; i += 2) {\n      var w = width * keypoints[i + 1] + keypoints[i];\n\n      var offsetsPosition = 0;\n      for (var j = 0, n = this.N; j < n; j++) {\n        if (pixels[offsets[offsetsPosition++] + w] < pixels[offsets[offsetsPosition++] + w]) {\n          // The bit in the position `j % 32` of descriptorWord should be set to 1. We do\n          // this by making an OR operation with a binary number that only has the bit\n          // in that position set to 1. That binary number is obtained by shifting 1 left by\n          // `j % 32` (which is the same as `j & 31` left) positions.\n          descriptorWord |= 1 << (j & 31);\n        }\n\n        // If the next j is a multiple of 32, we will need to use a new descriptor word to hold\n        // the next results.\n        if (!((j + 1) & 31)) {\n          descriptors[position++] = descriptorWord;\n          descriptorWord = 0;\n        }\n      }\n    }\n\n    return descriptors;\n  };\n\n  /**\n   * Matches sets of features {mi} and {m′j} extracted from two images taken\n   * from similar, and often successive, viewpoints. A classical procedure\n   * runs as follows. For each point {mi} in the first image, search in a\n   * region of the second image around location {mi} for point {m′j}. The\n   * search is based on the similarity of the local image windows, also known\n   * as kernel windows, centered on the points, which strongly characterizes\n   * the points when the images are sufficiently close. Once each keypoint is\n   * described with its binary string, they need to be compared with the\n   * closest matching point. Distance metric is critical to the performance of\n   * in- trusion detection systems. Thus using binary strings reduces the size\n   * of the descriptor and provides an interesting data structure that is fast\n   * to operate whose similarity can be measured by the Hamming distance.\n   * @param {array} keypoints1\n   * @param {array} descriptors1\n   * @param {array} keypoints2\n   * @param {array} descriptors2\n   * @return {Int32Array} Returns an array where the index is the corner1\n   *     index coordinate, and the value is the corresponding match index of\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\n   *     the return array would be [3,0].\n   * @static\n   */\n  tracking.Brief.match = function(keypoints1, descriptors1, keypoints2, descriptors2) {\n    var len1 = keypoints1.length >> 1;\n    var len2 = keypoints2.length >> 1;\n    var matches = new Array(len1);\n\n    for (var i = 0; i < len1; i++) {\n      var min = Infinity;\n      var minj = 0;\n      for (var j = 0; j < len2; j++) {\n        var dist = 0;\n        // Optimizing divide by 32 operation using binary shift\n        // (this.N >> 5) === this.N/32.\n        for (var k = 0, n = this.N >> 5; k < n; k++) {\n          dist += tracking.Math.hammingWeight(descriptors1[i * n + k] ^ descriptors2[j * n + k]);\n        }\n        if (dist < min) {\n          min = dist;\n          minj = j;\n        }\n      }\n      matches[i] = {\n        index1: i,\n        index2: minj,\n        keypoint1: [keypoints1[2 * i], keypoints1[2 * i + 1]],\n        keypoint2: [keypoints2[2 * minj], keypoints2[2 * minj + 1]],\n        confidence: 1 - min / this.N\n      };\n    }\n\n    return matches;\n  };\n\n  /**\n   * Removes matches outliers by testing matches on both directions.\n   * @param {array} keypoints1\n   * @param {array} descriptors1\n   * @param {array} keypoints2\n   * @param {array} descriptors2\n   * @return {Int32Array} Returns an array where the index is the corner1\n   *     index coordinate, and the value is the corresponding match index of\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\n   *     the return array would be [3,0].\n   * @static\n   */\n  tracking.Brief.reciprocalMatch = function(keypoints1, descriptors1, keypoints2, descriptors2) {\n    var matches = [];\n    if (keypoints1.length === 0 || keypoints2.length === 0) {\n      return matches;\n    }\n\n    var matches1 = tracking.Brief.match(keypoints1, descriptors1, keypoints2, descriptors2);\n    var matches2 = tracking.Brief.match(keypoints2, descriptors2, keypoints1, descriptors1);\n    for (var i = 0; i < matches1.length; i++) {\n      if (matches2[matches1[i].index2].index2 === i) {\n        matches.push(matches1[i]);\n      }\n    }\n    return matches;\n  };\n\n  /**\n   * Gets the coordinates values of (x,y)-location pairs uniquely chosen\n   * during the initialization.\n   * @return {array} Array with the random offset values.\n   * @private\n   */\n  tracking.Brief.getRandomOffsets_ = function(width) {\n    if (!this.randomWindowOffsets_) {\n      var windowPosition = 0;\n      var windowOffsets = new Int32Array(4 * this.N);\n      for (var i = 0; i < this.N; i++) {\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\n      }\n      this.randomWindowOffsets_ = windowOffsets;\n    }\n\n    if (!this.randomImageOffsets_[width]) {\n      var imagePosition = 0;\n      var imageOffsets = new Int32Array(2 * this.N);\n      for (var j = 0; j < this.N; j++) {\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j] * width + this.randomWindowOffsets_[4 * j + 1];\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j + 2] * width + this.randomWindowOffsets_[4 * j + 3];\n      }\n      this.randomImageOffsets_[width] = imageOffsets;\n    }\n\n    return this.randomImageOffsets_[width];\n  };\n}());\n\n(function() {\n  /**\n   * FAST intends for \"Features from Accelerated Segment Test\". This method\n   * performs a point segment test corner detection. The segment test\n   * criterion operates by considering a circle of sixteen pixels around the\n   * corner candidate p. The detector classifies p as a corner if there exists\n   * a set of n contiguous pixelsin the circle which are all brighter than the\n   * intensity of the candidate pixel Ip plus a threshold t, or all darker\n   * than Ip − t.\n   *\n   *       15 00 01\n   *    14          02\n   * 13                03\n   * 12       []       04\n   * 11                05\n   *    10          06\n   *       09 08 07\n   *\n   * For more reference:\n   * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.3991&rep=rep1&type=pdf\n   * @static\n   * @constructor\n   */\n  tracking.Fast = {};\n\n  /**\n   * Holds the threshold to determine whether the tested pixel is brighter or\n   * darker than the corner candidate p.\n   * @type {number}\n   * @default 40\n   * @static\n   */\n  tracking.Fast.THRESHOLD = 40;\n\n  /**\n   * Caches coordinates values of the circle surrounding the pixel candidate p.\n   * @type {Object.<number, Int32Array>}\n   * @private\n   * @static\n   */\n  tracking.Fast.circles_ = {};\n\n  /**\n   * Finds corners coordinates on the graysacaled image.\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {number} threshold to determine whether the tested pixel is brighter or\n   *     darker than the corner candidate p. Default value is 40.\n   * @return {array} Array containing the coordinates of all found corners,\n   *     e.g. [x0,y0,x1,y1,...], where P(x0,y0) represents a corner coordinate.\n   * @static\n   */\n  tracking.Fast.findCorners = function(pixels, width, height, opt_threshold) {\n    var circleOffsets = this.getCircleOffsets_(width);\n    var circlePixels = new Int32Array(16);\n    var corners = [];\n\n    if (opt_threshold === undefined) {\n      opt_threshold = this.THRESHOLD;\n    }\n\n    // When looping through the image pixels, skips the first three lines from\n    // the image boundaries to constrain the surrounding circle inside the image\n    // area.\n    for (var i = 3; i < height - 3; i++) {\n      for (var j = 3; j < width - 3; j++) {\n        var w = i * width + j;\n        var p = pixels[w];\n\n        // Loops the circle offsets to read the pixel value for the sixteen\n        // surrounding pixels.\n        for (var k = 0; k < 16; k++) {\n          circlePixels[k] = pixels[w + circleOffsets[k]];\n        }\n\n        if (this.isCorner(p, circlePixels, opt_threshold)) {\n          // The pixel p is classified as a corner, as optimization increment j\n          // by the circle radius 3 to skip the neighbor pixels inside the\n          // surrounding circle. This can be removed without compromising the\n          // result.\n          corners.push(j, i);\n          j += 3;\n        }\n      }\n    }\n\n    return corners;\n  };\n\n  /**\n   * Checks if the circle pixel is brighter than the candidate pixel p by\n   * a threshold.\n   * @param {number} circlePixel The circle pixel value.\n   * @param {number} p The value of the candidate pixel p.\n   * @param {number} threshold\n   * @return {Boolean}\n   * @static\n   */\n  tracking.Fast.isBrighter = function(circlePixel, p, threshold) {\n    return circlePixel - p > threshold;\n  };\n\n  /**\n   * Checks if the circle pixel is within the corner of the candidate pixel p\n   * by a threshold.\n   * @param {number} p The value of the candidate pixel p.\n   * @param {number} circlePixel The circle pixel value.\n   * @param {number} threshold\n   * @return {Boolean}\n   * @static\n   */\n  tracking.Fast.isCorner = function(p, circlePixels, threshold) {\n    if (this.isTriviallyExcluded(circlePixels, p, threshold)) {\n      return false;\n    }\n\n    for (var x = 0; x < 16; x++) {\n      var darker = true;\n      var brighter = true;\n\n      for (var y = 0; y < 9; y++) {\n        var circlePixel = circlePixels[(x + y) & 15];\n\n        if (!this.isBrighter(p, circlePixel, threshold)) {\n          brighter = false;\n          if (darker === false) {\n            break;\n          }\n        }\n\n        if (!this.isDarker(p, circlePixel, threshold)) {\n          darker = false;\n          if (brighter === false) {\n            break;\n          }\n        }\n      }\n\n      if (brighter || darker) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * Checks if the circle pixel is darker than the candidate pixel p by\n   * a threshold.\n   * @param {number} circlePixel The circle pixel value.\n   * @param {number} p The value of the candidate pixel p.\n   * @param {number} threshold\n   * @return {Boolean}\n   * @static\n   */\n  tracking.Fast.isDarker = function(circlePixel, p, threshold) {\n    return p - circlePixel > threshold;\n  };\n\n  /**\n   * Fast check to test if the candidate pixel is a trivially excluded value.\n   * In order to be a corner, the candidate pixel value should be darker or\n   * brighter than 9-12 surrounding pixels, when at least three of the top,\n   * bottom, left and right pixels are brighter or darker it can be\n   * automatically excluded improving the performance.\n   * @param {number} circlePixel The circle pixel value.\n   * @param {number} p The value of the candidate pixel p.\n   * @param {number} threshold\n   * @return {Boolean}\n   * @static\n   * @protected\n   */\n  tracking.Fast.isTriviallyExcluded = function(circlePixels, p, threshold) {\n    var count = 0;\n    var circleBottom = circlePixels[8];\n    var circleLeft = circlePixels[12];\n    var circleRight = circlePixels[4];\n    var circleTop = circlePixels[0];\n\n    if (this.isBrighter(circleTop, p, threshold)) {\n      count++;\n    }\n    if (this.isBrighter(circleRight, p, threshold)) {\n      count++;\n    }\n    if (this.isBrighter(circleBottom, p, threshold)) {\n      count++;\n    }\n    if (this.isBrighter(circleLeft, p, threshold)) {\n      count++;\n    }\n\n    if (count < 3) {\n      count = 0;\n      if (this.isDarker(circleTop, p, threshold)) {\n        count++;\n      }\n      if (this.isDarker(circleRight, p, threshold)) {\n        count++;\n      }\n      if (this.isDarker(circleBottom, p, threshold)) {\n        count++;\n      }\n      if (this.isDarker(circleLeft, p, threshold)) {\n        count++;\n      }\n      if (count < 3) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * Gets the sixteen offset values of the circle surrounding pixel.\n   * @param {number} width The image width.\n   * @return {array} Array with the sixteen offset values of the circle\n   *     surrounding pixel.\n   * @private\n   */\n  tracking.Fast.getCircleOffsets_ = function(width) {\n    if (this.circles_[width]) {\n      return this.circles_[width];\n    }\n\n    var circle = new Int32Array(16);\n\n    circle[0] = -width - width - width;\n    circle[1] = circle[0] + 1;\n    circle[2] = circle[1] + width + 1;\n    circle[3] = circle[2] + width + 1;\n    circle[4] = circle[3] + width;\n    circle[5] = circle[4] + width;\n    circle[6] = circle[5] + width - 1;\n    circle[7] = circle[6] + width - 1;\n    circle[8] = circle[7] - 1;\n    circle[9] = circle[8] - 1;\n    circle[10] = circle[9] - width - 1;\n    circle[11] = circle[10] - width - 1;\n    circle[12] = circle[11] - width;\n    circle[13] = circle[12] - width;\n    circle[14] = circle[13] - width + 1;\n    circle[15] = circle[14] - width + 1;\n\n    this.circles_[width] = circle;\n    return circle;\n  };\n}());\n\n(function() {\n  /**\n   * Math utility.\n   * @static\n   * @constructor\n   */\n  tracking.Math = {};\n\n  /**\n   * Euclidean distance between two points P(x0, y0) and P(x1, y1).\n   * @param {number} x0 Horizontal coordinate of P0.\n   * @param {number} y0 Vertical coordinate of P0.\n   * @param {number} x1 Horizontal coordinate of P1.\n   * @param {number} y1 Vertical coordinate of P1.\n   * @return {number} The euclidean distance.\n   */\n  tracking.Math.distance = function(x0, y0, x1, y1) {\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  /**\n   * Calculates the Hamming weight of a string, which is the number of symbols that are\n   * different from the zero-symbol of the alphabet used. It is thus\n   * equivalent to the Hamming distance from the all-zero string of the same\n   * length. For the most typical case, a string of bits, this is the number\n   * of 1's in the string.\n   *\n   * Example:\n   *\n   * <pre>\n   *  Binary string     Hamming weight\n   *   11101                 4\n   *   11101010              5\n   * </pre>\n   *\n   * @param {number} i Number that holds the binary string to extract the hamming weight.\n   * @return {number} The hamming weight.\n   */\n  tracking.Math.hammingWeight = function(i) {\n    i = i - ((i >> 1) & 0x55555555);\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n\n    return ((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\n  };\n\n  /**\n   * Generates a random number between [a, b] interval.\n   * @param {number} a\n   * @param {number} b\n   * @return {number}\n   */\n  tracking.Math.uniformRandom = function(a, b) {\n    return a + Math.random() * (b - a);\n  };\n\n  /**\n   * Tests if a rectangle intersects with another.\n   *\n   *  <pre>\n   *  x0y0 --------       x2y2 --------\n   *      |       |           |       |\n   *      -------- x1y1       -------- x3y3\n   * </pre>\n   *\n   * @param {number} x0 Horizontal coordinate of P0.\n   * @param {number} y0 Vertical coordinate of P0.\n   * @param {number} x1 Horizontal coordinate of P1.\n   * @param {number} y1 Vertical coordinate of P1.\n   * @param {number} x2 Horizontal coordinate of P2.\n   * @param {number} y2 Vertical coordinate of P2.\n   * @param {number} x3 Horizontal coordinate of P3.\n   * @param {number} y3 Vertical coordinate of P3.\n   * @return {boolean}\n   */\n  tracking.Math.intersectRect = function(x0, y0, x1, y1, x2, y2, x3, y3) {\n    return !(x2 > x1 || x3 < x0 || y2 > y1 || y3 < y0);\n  };\n\n}());\n\n(function() {\n  /**\n   * Matrix utility.\n   * @static\n   * @constructor\n   */\n  tracking.Matrix = {};\n\n  /**\n   * Loops the array organized as major-row order and executes `fn` callback\n   * for each iteration. The `fn` callback receives the following parameters:\n   * `(r,g,b,a,index,i,j)`, where `r,g,b,a` represents the pixel color with\n   * alpha channel, `index` represents the position in the major-row order\n   * array and `i,j` the respective indexes positions in two dimensions.\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\n   *     through.\n   * @param {number} width The image width.\n   * @param {number} height The image height.\n   * @param {function} fn The callback function for each pixel.\n   * @param {number} opt_jump Optional jump for the iteration, by default it\n   *     is 1, hence loops all the pixels of the array.\n   * @static\n   */\n  tracking.Matrix.forEach = function(pixels, width, height, fn, opt_jump) {\n    opt_jump = opt_jump || 1;\n    for (var i = 0; i < height; i += opt_jump) {\n      for (var j = 0; j < width; j += opt_jump) {\n        var w = i * width * 4 + j * 4;\n        fn.call(this, pixels[w], pixels[w + 1], pixels[w + 2], pixels[w + 3], w, i, j);\n      }\n    }\n  };\n\n}());\n\n(function() {\n  /**\n   * EPnp utility.\n   * @static\n   * @constructor\n   */\n  tracking.EPnP = {};\n\n  tracking.EPnP.solve = function(objectPoints, imagePoints, cameraMatrix) {};\n}());\n\n(function() {\n  /**\n   * Tracker utility.\n   * @constructor\n   * @extends {tracking.EventEmitter}\n   */\n  tracking.Tracker = function() {\n    tracking.Tracker.base(this, 'constructor');\n  };\n\n  tracking.inherits(tracking.Tracker, tracking.EventEmitter);\n\n  /**\n   * Tracks the pixels on the array. This method is called for each video\n   * frame in order to emit `track` event.\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\n   * @param {number} width The pixels canvas width.\n   * @param {number} height The pixels canvas height.\n   */\n  tracking.Tracker.prototype.track = function() {};\n}());\n\n(function() {\n  /**\n   * TrackerTask utility.\n   * @constructor\n   * @extends {tracking.EventEmitter}\n   */\n  tracking.TrackerTask = function(tracker) {\n    tracking.TrackerTask.base(this, 'constructor');\n\n    if (!tracker) {\n      throw new Error('Tracker instance not specified.');\n    }\n\n    this.setTracker(tracker);\n  };\n\n  tracking.inherits(tracking.TrackerTask, tracking.EventEmitter);\n\n  /**\n   * Holds the tracker instance managed by this task.\n   * @type {tracking.Tracker}\n   * @private\n   */\n  tracking.TrackerTask.prototype.tracker_ = null;\n\n  /**\n   * Holds if the tracker task is in running.\n   * @type {boolean}\n   * @private\n   */\n  tracking.TrackerTask.prototype.running_ = false;\n\n  /**\n   * Gets the tracker instance managed by this task.\n   * @return {tracking.Tracker}\n   */\n  tracking.TrackerTask.prototype.getTracker = function() {\n    return this.tracker_;\n  };\n\n  /**\n   * Returns true if the tracker task is in running, false otherwise.\n   * @return {boolean}\n   * @private\n   */\n  tracking.TrackerTask.prototype.inRunning = function() {\n    return this.running_;\n  };\n\n  /**\n   * Sets if the tracker task is in running.\n   * @param {boolean} running\n   * @private\n   */\n  tracking.TrackerTask.prototype.setRunning = function(running) {\n    this.running_ = running;\n  };\n\n  /**\n   * Sets the tracker instance managed by this task.\n   * @return {tracking.Tracker}\n   */\n  tracking.TrackerTask.prototype.setTracker = function(tracker) {\n    this.tracker_ = tracker;\n  };\n\n  /**\n   * Emits a `run` event on the tracker task for the implementers to run any\n   * child action, e.g. `requestAnimationFrame`.\n   * @return {object} Returns itself, so calls can be chained.\n   */\n  tracking.TrackerTask.prototype.run = function() {\n    var self = this;\n\n    if (this.inRunning()) {\n      return;\n    }\n\n    this.setRunning(true);\n    this.reemitTrackEvent_ = function(event) {\n      self.emit('track', event);\n    };\n    this.tracker_.on('track', this.reemitTrackEvent_);\n    this.emit('run');\n    return this;\n  };\n\n  /**\n   * Emits a `stop` event on the tracker task for the implementers to stop any\n   * child action being done, e.g. `requestAnimationFrame`.\n   * @return {object} Returns itself, so calls can be chained.\n   */\n  tracking.TrackerTask.prototype.stop = function() {\n    if (!this.inRunning()) {\n      return;\n    }\n\n    this.setRunning(false);\n    this.emit('stop');\n    this.tracker_.removeListener('track', this.reemitTrackEvent_);\n    return this;\n  };\n}());\n\n(function() {\n  /**\n   * ColorTracker utility to track colored blobs in a frame using color\n   * difference evaluation.\n   * @constructor\n   * @param {string|Array.<string>} opt_colors Optional colors to track.\n   * @extends {tracking.Tracker}\n   */\n  tracking.ColorTracker = function(opt_colors) {\n    tracking.ColorTracker.base(this, 'constructor');\n\n    if (typeof opt_colors === 'string') {\n      opt_colors = [opt_colors];\n    }\n\n    if (opt_colors) {\n      opt_colors.forEach(function(color) {\n        if (!tracking.ColorTracker.getColor(color)) {\n          throw new Error('Color not valid, try `new tracking.ColorTracker(\"magenta\")`.');\n        }\n      });\n      this.setColors(opt_colors);\n    }\n  };\n\n  tracking.inherits(tracking.ColorTracker, tracking.Tracker);\n\n  /**\n   * Holds the known colors.\n   * @type {Object.<string, function>}\n   * @private\n   * @static\n   */\n  tracking.ColorTracker.knownColors_ = {};\n\n  /**\n   * Caches coordinates values of the neighbours surrounding a pixel.\n   * @type {Object.<number, Int32Array>}\n   * @private\n   * @static\n   */\n  tracking.ColorTracker.neighbours_ = {};\n\n  /**\n   * Registers a color as known color.\n   * @param {string} name The color name.\n   * @param {function} fn The color function to test if the passed (r,g,b) is\n   *     the desired color.\n   * @static\n   */\n  tracking.ColorTracker.registerColor = function(name, fn) {\n    tracking.ColorTracker.knownColors_[name] = fn;\n  };\n\n  /**\n   * Gets the known color function that is able to test whether an (r,g,b) is\n   * the desired color.\n   * @param {string} name The color name.\n   * @return {function} The known color test function.\n   * @static\n   */\n  tracking.ColorTracker.getColor = function(name) {\n    return tracking.ColorTracker.knownColors_[name];\n  };\n\n  /**\n   * Holds the colors to be tracked by the `ColorTracker` instance.\n   * @default ['magenta']\n   * @type {Array.<string>}\n   */\n  tracking.ColorTracker.prototype.colors = ['magenta'];\n\n  /**\n   * Holds the minimum dimension to classify a rectangle.\n   * @default 20\n   * @type {number}\n   */\n  tracking.ColorTracker.prototype.minDimension = 20;\n\n  /**\n   * Holds the maximum dimension to classify a rectangle.\n   * @default Infinity\n   * @type {number}\n   */\n  tracking.ColorTracker.prototype.maxDimension = Infinity;\n\n\n  /**\n   * Holds the minimum group size to be classified as a rectangle.\n   * @default 30\n   * @type {number}\n   */\n  tracking.ColorTracker.prototype.minGroupSize = 30;\n\n  /**\n   * Calculates the central coordinate from the cloud points. The cloud points\n   * are all points that matches the desired color.\n   * @param {Array.<number>} cloud Major row order array containing all the\n   *     points from the desired color, e.g. [x1, y1, c2, y2, ...].\n   * @param {number} total Total numbers of pixels of the desired color.\n   * @return {object} Object containing the x, y and estimated z coordinate of\n   *     the blog extracted from the cloud points.\n   * @private\n   */\n  tracking.ColorTracker.prototype.calculateDimensions_ = function(cloud, total) {\n    var maxx = -1;\n    var maxy = -1;\n    var minx = Infinity;\n    var miny = Infinity;\n\n    for (var c = 0; c < total; c += 2) {\n      var x = cloud[c];\n      var y = cloud[c + 1];\n\n      if (x < minx) {\n        minx = x;\n      }\n      if (x > maxx) {\n        maxx = x;\n      }\n      if (y < miny) {\n        miny = y;\n      }\n      if (y > maxy) {\n        maxy = y;\n      }\n    }\n\n    return {\n      width: maxx - minx,\n      height: maxy - miny,\n      x: minx,\n      y: miny\n    };\n  };\n\n  /**\n   * Gets the colors being tracked by the `ColorTracker` instance.\n   * @return {Array.<string>}\n   */\n  tracking.ColorTracker.prototype.getColors = function() {\n    return this.colors;\n  };\n\n  /**\n   * Gets the minimum dimension to classify a rectangle.\n   * @return {number}\n   */\n  tracking.ColorTracker.prototype.getMinDimension = function() {\n    return this.minDimension;\n  };\n\n  /**\n   * Gets the maximum dimension to classify a rectangle.\n   * @return {number}\n   */\n  tracking.ColorTracker.prototype.getMaxDimension = function() {\n    return this.maxDimension;\n  };\n\n  /**\n   * Gets the minimum group size to be classified as a rectangle.\n   * @return {number}\n   */\n  tracking.ColorTracker.prototype.getMinGroupSize = function() {\n    return this.minGroupSize;\n  };\n\n  /**\n   * Gets the eight offset values of the neighbours surrounding a pixel.\n   * @param {number} width The image width.\n   * @return {array} Array with the eight offset values of the neighbours\n   *     surrounding a pixel.\n   * @private\n   */\n  tracking.ColorTracker.prototype.getNeighboursForWidth_ = function(width) {\n    if (tracking.ColorTracker.neighbours_[width]) {\n      return tracking.ColorTracker.neighbours_[width];\n    }\n\n    var neighbours = new Int32Array(8);\n\n    neighbours[0] = -width * 4;\n    neighbours[1] = -width * 4 + 4;\n    neighbours[2] = 4;\n    neighbours[3] = width * 4 + 4;\n    neighbours[4] = width * 4;\n    neighbours[5] = width * 4 - 4;\n    neighbours[6] = -4;\n    neighbours[7] = -width * 4 - 4;\n\n    tracking.ColorTracker.neighbours_[width] = neighbours;\n\n    return neighbours;\n  };\n\n  /**\n   * Unites groups whose bounding box intersect with each other.\n   * @param {Array.<Object>} rects\n   * @private\n   */\n  tracking.ColorTracker.prototype.mergeRectangles_ = function(rects) {\n    var intersects;\n    var results = [];\n    var minDimension = this.getMinDimension();\n    var maxDimension = this.getMaxDimension();\n\n    for (var r = 0; r < rects.length; r++) {\n      var r1 = rects[r];\n      intersects = true;\n      for (var s = r + 1; s < rects.length; s++) {\n        var r2 = rects[s];\n        if (tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\n          intersects = false;\n          var x1 = Math.min(r1.x, r2.x);\n          var y1 = Math.min(r1.y, r2.y);\n          var x2 = Math.max(r1.x + r1.width, r2.x + r2.width);\n          var y2 = Math.max(r1.y + r1.height, r2.y + r2.height);\n          r2.height = y2 - y1;\n          r2.width = x2 - x1;\n          r2.x = x1;\n          r2.y = y1;\n          break;\n        }\n      }\n\n      if (intersects) {\n        if (r1.width >= minDimension && r1.height >= minDimension) {\n          if (r1.width <= maxDimension && r1.height <= maxDimension) {\n            results.push(r1);\n          }\n        }\n      }\n    }\n\n    return results;\n  };\n\n  /**\n   * Sets the colors to be tracked by the `ColorTracker` instance.\n   * @param {Array.<string>} colors\n   */\n  tracking.ColorTracker.prototype.setColors = function(colors) {\n    this.colors = colors;\n  };\n\n  /**\n   * Sets the minimum dimension to classify a rectangle.\n   * @param {number} minDimension\n   */\n  tracking.ColorTracker.prototype.setMinDimension = function(minDimension) {\n    this.minDimension = minDimension;\n  };\n\n  /**\n   * Sets the maximum dimension to classify a rectangle.\n   * @param {number} maxDimension\n   */\n  tracking.ColorTracker.prototype.setMaxDimension = function(maxDimension) {\n    this.maxDimension = maxDimension;\n  };\n\n  /**\n   * Sets the minimum group size to be classified as a rectangle.\n   * @param {number} minGroupSize\n   */\n  tracking.ColorTracker.prototype.setMinGroupSize = function(minGroupSize) {\n    this.minGroupSize = minGroupSize;\n  };\n\n  /**\n   * Tracks the `Video` frames. This method is called for each video frame in\n   * order to emit `track` event.\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\n   * @param {number} width The pixels canvas width.\n   * @param {number} height The pixels canvas height.\n   */\n  tracking.ColorTracker.prototype.track = function(pixels, width, height) {\n    var self = this;\n    var colors = this.getColors();\n\n    if (!colors) {\n      throw new Error('Colors not specified, try `new tracking.ColorTracker(\"magenta\")`.');\n    }\n\n    var results = [];\n\n    colors.forEach(function(color) {\n      results = results.concat(self.trackColor_(pixels, width, height, color));\n    });\n\n    this.emit('track', {\n      data: results\n    });\n  };\n\n  /**\n   * Find the given color in the given matrix of pixels using Flood fill\n   * algorithm to determines the area connected to a given node in a\n   * multi-dimensional array.\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\n   * @param {number} width The pixels canvas width.\n   * @param {number} height The pixels canvas height.\n   * @param {string} color The color to be found\n   * @private\n   */\n  tracking.ColorTracker.prototype.trackColor_ = function(pixels, width, height, color) {\n    var colorFn = tracking.ColorTracker.knownColors_[color];\n    var currGroup = new Int32Array(pixels.length >> 2);\n    var currGroupSize;\n    var currI;\n    var currJ;\n    var currW;\n    var marked = new Int8Array(pixels.length);\n    var minGroupSize = this.getMinGroupSize();\n    var neighboursW = this.getNeighboursForWidth_(width);\n    var queue = new Int32Array(pixels.length);\n    var queuePosition;\n    var results = [];\n    var w = -4;\n\n    if (!colorFn) {\n      return results;\n    }\n\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        w += 4;\n\n        if (marked[w]) {\n          continue;\n        }\n\n        currGroupSize = 0;\n\n        queuePosition = -1;\n        queue[++queuePosition] = w;\n        queue[++queuePosition] = i;\n        queue[++queuePosition] = j;\n\n        marked[w] = 1;\n\n        while (queuePosition >= 0) {\n          currJ = queue[queuePosition--];\n          currI = queue[queuePosition--];\n          currW = queue[queuePosition--];\n\n          if (colorFn(pixels[currW], pixels[currW + 1], pixels[currW + 2], pixels[currW + 3], currW, currI, currJ)) {\n            currGroup[currGroupSize++] = currJ;\n            currGroup[currGroupSize++] = currI;\n\n            for (var k = 0; k < neighboursW.length; k++) {\n              var otherW = currW + neighboursW[k];\n              var otherI = currI + neighboursI[k];\n              var otherJ = currJ + neighboursJ[k];\n              if (!marked[otherW] && otherI >= 0 && otherI < height && otherJ >= 0 && otherJ < width) {\n                queue[++queuePosition] = otherW;\n                queue[++queuePosition] = otherI;\n                queue[++queuePosition] = otherJ;\n\n                marked[otherW] = 1;\n              }\n            }\n          }\n        }\n\n        if (currGroupSize >= minGroupSize) {\n          var data = this.calculateDimensions_(currGroup, currGroupSize);\n          if (data) {\n            data.color = color;\n            results.push(data);\n          }\n        }\n      }\n    }\n\n    return this.mergeRectangles_(results);\n  };\n\n  // Default colors\n  //===================\n\n  tracking.ColorTracker.registerColor('cyan', function(r, g, b) {\n    var thresholdGreen = 50,\n      thresholdBlue = 70,\n      dx = r - 0,\n      dy = g - 255,\n      dz = b - 255;\n\n    if ((g - r) >= thresholdGreen && (b - r) >= thresholdBlue) {\n      return true;\n    }\n    return dx * dx + dy * dy + dz * dz < 6400;\n  });\n\n  tracking.ColorTracker.registerColor('magenta', function(r, g, b) {\n    var threshold = 50,\n      dx = r - 255,\n      dy = g - 0,\n      dz = b - 255;\n\n    if ((r - g) >= threshold && (b - g) >= threshold) {\n      return true;\n    }\n    return dx * dx + dy * dy + dz * dz < 19600;\n  });\n\n  tracking.ColorTracker.registerColor('yellow', function(r, g, b) {\n    var threshold = 50,\n      dx = r - 255,\n      dy = g - 255,\n      dz = b - 0;\n\n    if ((r - b) >= threshold && (g - b) >= threshold) {\n      return true;\n    }\n    return dx * dx + dy * dy + dz * dz < 10000;\n  });\n\n\n  // Caching neighbour i/j offset values.\n  //=====================================\n  var neighboursI = new Int32Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n  var neighboursJ = new Int32Array([0, 1, 1, 1, 0, -1, -1, -1]);\n}());\n\n(function() {\n  /**\n   * ObjectTracker utility.\n   * @constructor\n   * @param {string|Array.<string|Array.<number>>} opt_classifiers Optional\n   *     object classifiers to track.\n   * @extends {tracking.Tracker}\n   */\n  tracking.ObjectTracker = function(opt_classifiers) {\n    tracking.ObjectTracker.base(this, 'constructor');\n\n    if (opt_classifiers) {\n      if (!Array.isArray(opt_classifiers)) {\n        opt_classifiers = [opt_classifiers];\n      }\n\n      if (Array.isArray(opt_classifiers)) {\n        opt_classifiers.forEach(function(classifier, i) {\n          if (typeof classifier === 'string') {\n            opt_classifiers[i] = tracking.ViolaJones.classifiers[classifier];\n          }\n          if (!opt_classifiers[i]) {\n            throw new Error('Object classifier not valid, try `new tracking.ObjectTracker(\"face\")`.');\n          }\n        });\n      }\n    }\n\n    this.setClassifiers(opt_classifiers);\n  };\n\n  tracking.inherits(tracking.ObjectTracker, tracking.Tracker);\n\n  /**\n   * Specifies the edges density of a block in order to decide whether to skip\n   * it or not.\n   * @default 0.2\n   * @type {number}\n   */\n  tracking.ObjectTracker.prototype.edgesDensity = 0.2;\n\n  /**\n   * Specifies the initial scale to start the feature block scaling.\n   * @default 1.0\n   * @type {number}\n   */\n  tracking.ObjectTracker.prototype.initialScale = 1.0;\n\n  /**\n   * Specifies the scale factor to scale the feature block.\n   * @default 1.25\n   * @type {number}\n   */\n  tracking.ObjectTracker.prototype.scaleFactor = 1.25;\n\n  /**\n   * Specifies the block step size.\n   * @default 1.5\n   * @type {number}\n   */\n  tracking.ObjectTracker.prototype.stepSize = 1.5;\n\n  /**\n   * Gets the tracker HAAR classifiers.\n   * @return {TypedArray.<number>}\n   */\n  tracking.ObjectTracker.prototype.getClassifiers = function() {\n    return this.classifiers;\n  };\n\n  /**\n   * Gets the edges density value.\n   * @return {number}\n   */\n  tracking.ObjectTracker.prototype.getEdgesDensity = function() {\n    return this.edgesDensity;\n  };\n\n  /**\n   * Gets the initial scale to start the feature block scaling.\n   * @return {number}\n   */\n  tracking.ObjectTracker.prototype.getInitialScale = function() {\n    return this.initialScale;\n  };\n\n  /**\n   * Gets the scale factor to scale the feature block.\n   * @return {number}\n   */\n  tracking.ObjectTracker.prototype.getScaleFactor = function() {\n    return this.scaleFactor;\n  };\n\n  /**\n   * Gets the block step size.\n   * @return {number}\n   */\n  tracking.ObjectTracker.prototype.getStepSize = function() {\n    return this.stepSize;\n  };\n\n  /**\n   * Tracks the `Video` frames. This method is called for each video frame in\n   * order to emit `track` event.\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\n   * @param {number} width The pixels canvas width.\n   * @param {number} height The pixels canvas height.\n   */\n  tracking.ObjectTracker.prototype.track = function(pixels, width, height) {\n    var self = this;\n    var classifiers = this.getClassifiers();\n\n    if (!classifiers) {\n      throw new Error('Object classifier not specified, try `new tracking.ObjectTracker(\"face\")`.');\n    }\n\n    var results = [];\n\n    classifiers.forEach(function(classifier) {\n      results = results.concat(tracking.ViolaJones.detect(pixels, width, height, self.getInitialScale(), self.getScaleFactor(), self.getStepSize(), self.getEdgesDensity(), classifier));\n    });\n\n    this.emit('track', {\n      data: results\n    });\n  };\n\n  /**\n   * Sets the tracker HAAR classifiers.\n   * @param {TypedArray.<number>} classifiers\n   */\n  tracking.ObjectTracker.prototype.setClassifiers = function(classifiers) {\n    this.classifiers = classifiers;\n  };\n\n  /**\n   * Sets the edges density.\n   * @param {number} edgesDensity\n   */\n  tracking.ObjectTracker.prototype.setEdgesDensity = function(edgesDensity) {\n    this.edgesDensity = edgesDensity;\n  };\n\n  /**\n   * Sets the initial scale to start the block scaling.\n   * @param {number} initialScale\n   */\n  tracking.ObjectTracker.prototype.setInitialScale = function(initialScale) {\n    this.initialScale = initialScale;\n  };\n\n  /**\n   * Sets the scale factor to scale the feature block.\n   * @param {number} scaleFactor\n   */\n  tracking.ObjectTracker.prototype.setScaleFactor = function(scaleFactor) {\n    this.scaleFactor = scaleFactor;\n  };\n\n  /**\n   * Sets the block step size.\n   * @param {number} stepSize\n   */\n  tracking.ObjectTracker.prototype.setStepSize = function(stepSize) {\n    this.stepSize = stepSize;\n  };\n\n}());\n"]},"metadata":{},"sourceType":"script"}